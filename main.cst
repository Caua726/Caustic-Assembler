use "../std/linux.cst" as linux;
use "../std/mem.cst" as mem;
use "lexer.cst" as lex;
use "encoder.cst" as enc;
use "elf.cst" as elf;

// Section IDs
let is i32 as SECTION_TEXT   with imut = 0;
let is i32 as SECTION_DATA   with imut = 1;
let is i32 as SECTION_RODATA with imut = 2;
let is i32 as SECTION_BSS    with imut = 3;
let is i32 as SECTION_UNDEF  with imut = 99;

// Line kinds
let is i32 as LINE_EMPTY     with imut = 0;
let is i32 as LINE_LABEL     with imut = 1;
let is i32 as LINE_INST      with imut = 2;
let is i32 as LINE_DIRECTIVE with imut = 3;

// Directive kinds
let is i32 as DIR_TEXT     with imut = 1;
let is i32 as DIR_DATA     with imut = 2;
let is i32 as DIR_RODATA   with imut = 3;
let is i32 as DIR_BSS      with imut = 4;
let is i32 as DIR_GLOBL    with imut = 5;
let is i32 as DIR_STRING   with imut = 6;
let is i32 as DIR_BYTE     with imut = 7;
let is i32 as DIR_WORD     with imut = 8;
let is i32 as DIR_LONG     with imut = 9;
let is i32 as DIR_QUAD     with imut = 10;
let is i32 as DIR_ZERO     with imut = 11;
let is i32 as DIR_SECTION  with imut = 12;
let is i32 as DIR_INTEL    with imut = 13;
let is i32 as DIR_OTHER    with imut = 14;

struct ParsedLine {
    kind as i32;
    section as i32;
    inst_id as i32;
    // op1 flattened
    op1_kind as i32;
    op1_reg_id as i32;
    op1_imm as i64;
    op1_mem_base as i32;
    op1_mem_disp as i64;
    op1_mem_size as i32;
    op1_label_ptr as *u8;
    op1_label_len as i32;
    // op2 flattened
    op2_kind as i32;
    op2_reg_id as i32;
    op2_imm as i64;
    op2_mem_base as i32;
    op2_mem_disp as i64;
    op2_mem_size as i32;
    op2_label_ptr as *u8;
    op2_label_len as i32;
    // other
    label_ptr as *u8;
    label_len as i32;
    dir_kind as i32;
    dir_arg_ptr as *u8;
    dir_arg_len as i32;
    dir_num as i64;
    offset as i64;
    size as i32;
    line_no as i32;
}

struct ParsedLines {
    data as *u8;
    count as i32;
    cap as i32;
}

fn pl_init() as ParsedLines {
    let is i32 as cap = 4096;
    let is ParsedLines as pl;
    pl.data = mem.galloc(cast(i64, cap) * sizeof(ParsedLine));
    pl.count = 0;
    pl.cap = cap;
    return pl;
}

fn pl_get(pl as *ParsedLines, idx as i32) as *ParsedLine {
    return cast(*ParsedLine, cast(i64, pl.data) + cast(i64, idx) * sizeof(ParsedLine));
}

fn pl_add(pl as *ParsedLines) as *ParsedLine {
    if (pl.count >= pl.cap) {
        let is i32 as new_cap = pl.cap * 2;
        let is *u8 as new_data = mem.galloc(cast(i64, new_cap) * sizeof(ParsedLine));
        mem.memcpy(new_data, pl.data, cast(i64, pl.count) * sizeof(ParsedLine));
        mem.gfree(pl.data);
        pl.data = new_data;
        pl.cap = new_cap;
    }
    let is *ParsedLine as line = pl_get(pl, pl.count);
    line.kind = LINE_EMPTY;
    line.section = SECTION_TEXT;
    line.inst_id = enc.INST_NONE;
    line.op1_kind = enc.OP_NONE;
    line.op1_reg_id = enc.REG_NONE;
    line.op1_imm = 0;
    line.op1_mem_base = enc.REG_NONE;
    line.op1_mem_disp = 0;
    line.op1_mem_size = 0;
    line.op1_label_ptr = cast(*u8, 0);
    line.op1_label_len = 0;
    line.op2_kind = enc.OP_NONE;
    line.op2_reg_id = enc.REG_NONE;
    line.op2_imm = 0;
    line.op2_mem_base = enc.REG_NONE;
    line.op2_mem_disp = 0;
    line.op2_mem_size = 0;
    line.op2_label_ptr = cast(*u8, 0);
    line.op2_label_len = 0;
    line.label_ptr = cast(*u8, 0);
    line.label_len = 0;
    line.dir_kind = 0;
    line.dir_arg_ptr = cast(*u8, 0);
    line.dir_arg_len = 0;
    line.dir_num = 0;
    line.offset = 0;
    line.size = 0;
    line.line_no = 0;
    pl.count = pl.count + 1;
    return line;
}

// Helpers to build Operand from flattened line fields
fn make_op(line as *ParsedLine, which as i32) as enc.Operand {
    let is enc.Operand as op;
    if (which == 1) {
        op.kind = line.op1_kind;
        op.reg_id = line.op1_reg_id;
        op.imm = line.op1_imm;
        op.mem_base = line.op1_mem_base;
        op.mem_disp = line.op1_mem_disp;
        op.mem_size = line.op1_mem_size;
        op.label_ptr = line.op1_label_ptr;
        op.label_len = line.op1_label_len;
    } else {
        op.kind = line.op2_kind;
        op.reg_id = line.op2_reg_id;
        op.imm = line.op2_imm;
        op.mem_base = line.op2_mem_base;
        op.mem_disp = line.op2_mem_disp;
        op.mem_size = line.op2_mem_size;
        op.label_ptr = line.op2_label_ptr;
        op.label_len = line.op2_label_len;
    }
    return op;
}

fn set_op_reg(line as *ParsedLine, which as i32, reg_id as i32) as void {
    if (which == 1) { line.op1_kind = enc.OP_REG; line.op1_reg_id = reg_id; }
    else { line.op2_kind = enc.OP_REG; line.op2_reg_id = reg_id; }
}

fn set_op_imm(line as *ParsedLine, which as i32, val as i64) as void {
    if (which == 1) { line.op1_kind = enc.OP_IMM; line.op1_imm = val; }
    else { line.op2_kind = enc.OP_IMM; line.op2_imm = val; }
}

fn set_op_mem(line as *ParsedLine, which as i32, base as i32, disp as i64, sz as i32) as void {
    if (which == 1) { line.op1_kind = enc.OP_MEM; line.op1_mem_base = base; line.op1_mem_disp = disp; line.op1_mem_size = sz; }
    else { line.op2_kind = enc.OP_MEM; line.op2_mem_base = base; line.op2_mem_disp = disp; line.op2_mem_size = sz; }
}

fn set_op_label(line as *ParsedLine, which as i32, ptr as *u8, len as i32) as void {
    if (which == 1) { line.op1_kind = enc.OP_LABEL; line.op1_label_ptr = ptr; line.op1_label_len = len; }
    else { line.op2_kind = enc.OP_LABEL; line.op2_label_ptr = ptr; line.op2_label_len = len; }
}

fn set_op_rip(line as *ParsedLine, which as i32, ptr as *u8, len as i32, sz as i32) as void {
    if (which == 1) { line.op1_kind = enc.OP_RIP_LABEL; line.op1_label_ptr = ptr; line.op1_label_len = len; line.op1_mem_size = sz; }
    else { line.op2_kind = enc.OP_RIP_LABEL; line.op2_label_ptr = ptr; line.op2_label_len = len; line.op2_mem_size = sz; }
}

// Parse an operand starting at token index pos, stores into line's op1 or op2
fn parse_operand(tl as *lex.TokenList, pos as i32, out_pos as *i32, line as *ParsedLine, which as i32) as void {
    let is *lex.Token as tok = lex.tl_get(tl, pos);

    if (tok.kind == lex.TK_REGISTER) {
        *out_pos = pos + 1;
        set_op_reg(line, which, tok.reg_id);
        return;
    }
    if (tok.kind == lex.TK_NUMBER) {
        *out_pos = pos + 1;
        set_op_imm(line, which, tok.num_val);
        return;
    }
    if (tok.kind == lex.TK_MINUS) {
        let is *lex.Token as next = lex.tl_get(tl, pos + 1);
        if (next.kind == lex.TK_NUMBER) {
            *out_pos = pos + 2;
            set_op_imm(line, which, 0 - next.num_val);
            return;
        }
    }
    if (tok.kind == lex.TK_SIZE_PREFIX) {
        let is i32 as mem_size = tok.size_val;
        let is *lex.Token as lb = lex.tl_get(tl, pos + 1);
        if (lb.kind == lex.TK_LBRACKET) {
            let is i32 as p with mut = pos + 2;
            let is *lex.Token as base_tok = lex.tl_get(tl, p);
            let is i32 as base_reg = base_tok.reg_id;
            p = p + 1;
            if (base_reg == 99) {
                let is *lex.Token as op_tok = lex.tl_get(tl, p);
                if (op_tok.kind == lex.TK_PLUS) {
                    p = p + 1;
                    let is *lex.Token as lab_tok = lex.tl_get(tl, p);
                    p = p + 1;
                    let is *lex.Token as rb = lex.tl_get(tl, p);
                    if (rb.kind == lex.TK_RBRACKET) { p = p + 1; }
                    *out_pos = p;
                    set_op_rip(line, which, lab_tok.ptr, lab_tok.len, mem_size);
                    return;
                }
            }
            let is i64 as disp with mut = 0;
            let is *lex.Token as next2 = lex.tl_get(tl, p);
            if (next2.kind == lex.TK_PLUS) {
                p = p + 1;
                let is *lex.Token as d = lex.tl_get(tl, p);
                disp = d.num_val;
                p = p + 1;
            } else if (next2.kind == lex.TK_MINUS) {
                p = p + 1;
                let is *lex.Token as d = lex.tl_get(tl, p);
                disp = 0 - d.num_val;
                p = p + 1;
            }
            let is *lex.Token as rb2 = lex.tl_get(tl, p);
            if (rb2.kind == lex.TK_RBRACKET) { p = p + 1; }
            *out_pos = p;
            set_op_mem(line, which, base_reg, disp, mem_size);
            return;
        }
    }
    if (tok.kind == lex.TK_LBRACKET) {
        let is i32 as p with mut = pos + 1;
        let is *lex.Token as base_tok = lex.tl_get(tl, p);
        let is i32 as base_reg = base_tok.reg_id;
        p = p + 1;
        if (base_reg == 99) {
            let is *lex.Token as op_tok = lex.tl_get(tl, p);
            if (op_tok.kind == lex.TK_PLUS) {
                p = p + 1;
                let is *lex.Token as lab_tok = lex.tl_get(tl, p);
                p = p + 1;
                let is *lex.Token as rb = lex.tl_get(tl, p);
                if (rb.kind == lex.TK_RBRACKET) { p = p + 1; }
                *out_pos = p;
                set_op_rip(line, which, lab_tok.ptr, lab_tok.len, 0);
                return;
            }
        }
        let is i64 as disp with mut = 0;
        let is *lex.Token as next2 = lex.tl_get(tl, p);
        if (next2.kind == lex.TK_PLUS) {
            p = p + 1;
            let is *lex.Token as d = lex.tl_get(tl, p);
            disp = d.num_val;
            p = p + 1;
        } else if (next2.kind == lex.TK_MINUS) {
            p = p + 1;
            let is *lex.Token as d = lex.tl_get(tl, p);
            disp = 0 - d.num_val;
            p = p + 1;
        }
        let is *lex.Token as rb2 = lex.tl_get(tl, p);
        if (rb2.kind == lex.TK_RBRACKET) { p = p + 1; }
        *out_pos = p;
        set_op_mem(line, which, base_reg, disp, 0);
        return;
    }
    if (tok.kind == lex.TK_IDENT || tok.kind == lex.TK_INSTRUCTION) {
        *out_pos = pos + 1;
        set_op_label(line, which, tok.ptr, tok.len);
        return;
    }
    *out_pos = pos;
}

// Decode escape sequences in a string literal and return the byte data
fn decode_string(ptr as *u8, len as i32, out_len as *i32) as *u8 {
    // ptr includes the surrounding quotes
    let is *u8 as buf = mem.galloc(cast(i64, len));
    let is i32 as out with mut = 0;
    let is i32 as i with mut = 1; // skip opening quote
    let is i32 as end = len - 1; // skip closing quote

    while (i < end) {
        if (ptr[i] == 92) { // backslash
            i = i + 1;
            if (i >= end) { break; }
            if (ptr[i] == 110) { buf[out] = 10; } // \n
            else if (ptr[i] == 116) { buf[out] = 9; } // \t
            else if (ptr[i] == 48) { buf[out] = 0; } // \0
            else if (ptr[i] == 92) { buf[out] = 92; } // \\
            else if (ptr[i] == 34) { buf[out] = 34; } // \"
            else { buf[out] = ptr[i]; }
        } else {
            buf[out] = ptr[i];
        }
        out = out + 1;
        i = i + 1;
    }
    *out_len = out;
    return buf;
}

// Parse tokens into ParsedLines
fn parse_all(tl as *lex.TokenList) as ParsedLines {
    let is ParsedLines as lines = pl_init();
    let is i32 as pos with mut = 0;
    let is i32 as current_section with mut = SECTION_TEXT;

    while (pos < tl.count) {
        let is *lex.Token as tok = lex.tl_get(tl, pos);

        // Skip newlines
        if (tok.kind == lex.TK_NEWLINE || tok.kind == lex.TK_EOF) {
            if (tok.kind == lex.TK_EOF) { break; }
            pos = pos + 1;
        }
        // Directive
        else if (tok.kind == lex.TK_DIRECTIVE) {
            let is *ParsedLine as line = pl_add(&lines);
            line.kind = LINE_DIRECTIVE;
            line.section = current_section;
            line.line_no = tok.line;

            if (enc.streq_lit(tok.ptr, tok.len, ".intel_syntax") == 1) {
                line.dir_kind = DIR_INTEL;
                // Skip rest of line
                pos = pos + 1;
                while (pos < tl.count) {
                    let is *lex.Token as t = lex.tl_get(tl, pos);
                    if (t.kind == lex.TK_NEWLINE || t.kind == lex.TK_EOF) { break; }
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".text") == 1) {
                line.dir_kind = DIR_TEXT;
                current_section = SECTION_TEXT;
                pos = pos + 1;
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".data") == 1) {
                line.dir_kind = DIR_DATA;
                current_section = SECTION_DATA;
                pos = pos + 1;
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".bss") == 1) {
                line.dir_kind = DIR_BSS;
                current_section = SECTION_BSS;
                pos = pos + 1;
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".section") == 1) {
                line.dir_kind = DIR_SECTION;
                pos = pos + 1;
                // Next token is section name
                let is *lex.Token as sec_tok = lex.tl_get(tl, pos);
                if (sec_tok.kind != lex.TK_NEWLINE && sec_tok.kind != lex.TK_EOF) {
                    if (enc.streq_lit(sec_tok.ptr, sec_tok.len, ".rodata") == 1) {
                        current_section = SECTION_RODATA;
                    } else if (enc.streq_lit(sec_tok.ptr, sec_tok.len, ".data") == 1) {
                        current_section = SECTION_DATA;
                    } else if (enc.streq_lit(sec_tok.ptr, sec_tok.len, ".bss") == 1) {
                        current_section = SECTION_BSS;
                    } else if (enc.streq_lit(sec_tok.ptr, sec_tok.len, ".text") == 1) {
                        current_section = SECTION_TEXT;
                    }
                    pos = pos + 1;
                }
                line.section = current_section;
                // Skip rest of line
                while (pos < tl.count) {
                    let is *lex.Token as t = lex.tl_get(tl, pos);
                    if (t.kind == lex.TK_NEWLINE || t.kind == lex.TK_EOF) { break; }
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".globl") == 1 || enc.streq_lit(tok.ptr, tok.len, ".global") == 1) {
                line.dir_kind = DIR_GLOBL;
                pos = pos + 1;
                let is *lex.Token as name_tok = lex.tl_get(tl, pos);
                if (name_tok.kind != lex.TK_NEWLINE && name_tok.kind != lex.TK_EOF) {
                    line.dir_arg_ptr = name_tok.ptr;
                    line.dir_arg_len = name_tok.len;
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".rodata") == 1) {
                line.dir_kind = DIR_RODATA;
                current_section = SECTION_RODATA;
                pos = pos + 1;
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".string") == 1 || enc.streq_lit(tok.ptr, tok.len, ".asciz") == 1) {
                line.dir_kind = DIR_STRING;
                line.section = current_section;
                pos = pos + 1;
                let is *lex.Token as str_tok = lex.tl_get(tl, pos);
                if (str_tok.kind == lex.TK_STRING) {
                    line.dir_arg_ptr = str_tok.ptr;
                    line.dir_arg_len = str_tok.len;
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".byte") == 1) {
                line.dir_kind = DIR_BYTE;
                line.section = current_section;
                pos = pos + 1;
                let is *lex.Token as val_tok = lex.tl_get(tl, pos);
                if (val_tok.kind == lex.TK_NUMBER) {
                    line.dir_num = val_tok.num_val;
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".word") == 1 || enc.streq_lit(tok.ptr, tok.len, ".value") == 1) {
                line.dir_kind = DIR_WORD;
                line.section = current_section;
                pos = pos + 1;
                let is *lex.Token as val_tok = lex.tl_get(tl, pos);
                if (val_tok.kind == lex.TK_NUMBER) {
                    line.dir_num = val_tok.num_val;
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".long") == 1) {
                line.dir_kind = DIR_LONG;
                line.section = current_section;
                pos = pos + 1;
                let is *lex.Token as val_tok = lex.tl_get(tl, pos);
                if (val_tok.kind == lex.TK_NUMBER) {
                    line.dir_num = val_tok.num_val;
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".quad") == 1) {
                line.dir_kind = DIR_QUAD;
                line.section = current_section;
                pos = pos + 1;
                let is *lex.Token as val_tok = lex.tl_get(tl, pos);
                if (val_tok.kind == lex.TK_NUMBER) {
                    line.dir_num = val_tok.num_val;
                    pos = pos + 1;
                } else if (val_tok.kind == lex.TK_MINUS) {
                    pos = pos + 1;
                    let is *lex.Token as n = lex.tl_get(tl, pos);
                    line.dir_num = 0 - n.num_val;
                    pos = pos + 1;
                }
            }
            else if (enc.streq_lit(tok.ptr, tok.len, ".zero") == 1) {
                line.dir_kind = DIR_ZERO;
                line.section = current_section;
                pos = pos + 1;
                let is *lex.Token as val_tok = lex.tl_get(tl, pos);
                if (val_tok.kind == lex.TK_NUMBER) {
                    line.dir_num = val_tok.num_val;
                    pos = pos + 1;
                }
            }
            else {
                line.dir_kind = DIR_OTHER;
                pos = pos + 1;
            }
            // Skip to end of line
            while (pos < tl.count) {
                let is *lex.Token as t = lex.tl_get(tl, pos);
                if (t.kind == lex.TK_NEWLINE || t.kind == lex.TK_EOF) { break; }
                pos = pos + 1;
            }
        }
        // Instruction (but check for label first: "add:" etc.)
        else if (tok.kind == lex.TK_INSTRUCTION) {
            let is *lex.Token as peek = lex.tl_get(tl, pos + 1);
            if (peek.kind == lex.TK_COLON) {
                // It's a label that happens to share name with an instruction
                let is *ParsedLine as lbl = pl_add(&lines);
                lbl.kind = LINE_LABEL;
                lbl.section = current_section;
                lbl.label_ptr = tok.ptr;
                lbl.label_len = tok.len;
                lbl.line_no = tok.line;
                pos = pos + 2;
            } else {
            let is *ParsedLine as line = pl_add(&lines);
            line.kind = LINE_INST;
            line.section = current_section;
            line.inst_id = tok.inst_id;
            line.line_no = tok.line;
            pos = pos + 1;

            // Handle "rep movsb" — don't skip to end of line for REP
            if (tok.inst_id == enc.INST_REP) {
                // Just emit the REP prefix, movsb follows as next iteration
            } else {
                // Parse operand 1
                let is *lex.Token as next = lex.tl_get(tl, pos);
                if (next.kind != lex.TK_NEWLINE && next.kind != lex.TK_EOF) {
                    let is i32 as new_pos with mut = pos;
                    parse_operand(tl, pos, &new_pos, line, 1);
                    pos = new_pos;

                    // Check for comma -> operand 2
                    let is *lex.Token as comma = lex.tl_get(tl, pos);
                    if (comma.kind == lex.TK_COMMA) {
                        pos = pos + 1;
                        parse_operand(tl, pos, &new_pos, line, 2);
                        pos = new_pos;
                    }
                }
                // Skip to end of line
                while (pos < tl.count) {
                    let is *lex.Token as t = lex.tl_get(tl, pos);
                    if (t.kind == lex.TK_NEWLINE || t.kind == lex.TK_EOF) { break; }
                    pos = pos + 1;
                }
            }
            } // end else (not label)
        }
        // Label (IDENT followed by COLON)
        else if (tok.kind == lex.TK_IDENT) {
            let is *lex.Token as next = lex.tl_get(tl, pos + 1);
            if (next.kind == lex.TK_COLON) {
                let is *ParsedLine as line = pl_add(&lines);
                line.kind = LINE_LABEL;
                line.section = current_section;
                line.label_ptr = tok.ptr;
                line.label_len = tok.len;
                line.line_no = tok.line;
                pos = pos + 2;
            } else {
                // Unknown identifier, skip line
                pos = pos + 1;
                while (pos < tl.count) {
                    let is *lex.Token as t = lex.tl_get(tl, pos);
                    if (t.kind == lex.TK_NEWLINE || t.kind == lex.TK_EOF) { break; }
                    pos = pos + 1;
                }
            }
        }
        else {
            // Skip unknown token
            pos = pos + 1;
        }
    }

    return lines;
}

// Calculate instruction size for pass 1
fn calc_inst_size(line as *ParsedLine) as i32 {
    let is enc.ByteBuffer as tmp = enc.buf_init(32);
    let is enc.Operand as o1 = make_op(line, 1);
    let is enc.Operand as o2 = make_op(line, 2);
    let is i32 as sz = enc.encode(&tmp, line.inst_id, &o1, &o2, 0, 0);
    mem.gfree(tmp.data);
    return sz;
}

// Calculate directive data size
fn calc_dir_size(line as *ParsedLine) as i32 {
    if (line.dir_kind == DIR_STRING) {
        // Decode string to count actual bytes + null terminator
        let is i32 as decoded_len with mut = 0;
        let is *u8 as decoded = decode_string(line.dir_arg_ptr, line.dir_arg_len, &decoded_len);
        mem.gfree(decoded);
        return decoded_len + 1; // +1 for null terminator
    }
    if (line.dir_kind == DIR_BYTE) { return 1; }
    if (line.dir_kind == DIR_WORD) { return 2; }
    if (line.dir_kind == DIR_LONG) { return 4; }
    if (line.dir_kind == DIR_QUAD) { return 8; }
    if (line.dir_kind == DIR_ZERO) { return cast(i32, line.dir_num); }
    return 0;
}

// Pass 1: collect symbols, calculate sizes
fn pass1(lines as *ParsedLines, symtab as *elf.SymbolTable) as void {
    let is i64 as text_off with mut = 0;
    let is i64 as data_off with mut = 0;
    let is i64 as rodata_off with mut = 0;
    let is i64 as bss_off with mut = 0;
    let is i32 as i with mut = 0;

    while (i < lines.count) {
        let is *ParsedLine as line = pl_get(lines, i);

        if (line.kind == LINE_LABEL) {
            let is i64 as off with mut = 0;
            if (line.section == SECTION_TEXT) { off = text_off; }
            else if (line.section == SECTION_DATA) { off = data_off; }
            else if (line.section == SECTION_RODATA) { off = rodata_off; }
            else if (line.section == SECTION_BSS) { off = bss_off; }
            elf.sym_find_or_add(symtab, line.label_ptr, line.label_len, line.section, off, 0);
        }
        else if (line.kind == LINE_DIRECTIVE) {
            if (line.dir_kind == DIR_GLOBL) {
                elf.sym_find_or_add(symtab, line.dir_arg_ptr, line.dir_arg_len, SECTION_UNDEF, 0, 1);
            }
            else if (line.dir_kind == DIR_STRING || line.dir_kind == DIR_BYTE || line.dir_kind == DIR_WORD ||
                     line.dir_kind == DIR_LONG || line.dir_kind == DIR_QUAD || line.dir_kind == DIR_ZERO) {
                let is i32 as sz = calc_dir_size(line);
                line.size = sz;
                if (line.section == SECTION_TEXT)   { line.offset = text_off; text_off = text_off + cast(i64, sz); }
                if (line.section == SECTION_DATA)   { line.offset = data_off; data_off = data_off + cast(i64, sz); }
                if (line.section == SECTION_RODATA) { line.offset = rodata_off; rodata_off = rodata_off + cast(i64, sz); }
                if (line.section == SECTION_BSS)    { line.offset = bss_off; bss_off = bss_off + cast(i64, sz); }
            }
        }
        else if (line.kind == LINE_INST) {
            let is i32 as sz = calc_inst_size(line);
            line.size = sz;
            line.offset = text_off;
            text_off = text_off + cast(i64, sz);
        }
        i = i + 1;
    }
}

// Pass 2: encode instructions and emit data
fn pass2(lines as *ParsedLines, symtab as *elf.SymbolTable, text_buf as *enc.ByteBuffer,
         data_buf as *enc.ByteBuffer, rodata_buf as *enc.ByteBuffer, bss_size as *i64,
         relocs as *elf.RelocList) as void {
    let is i32 as i with mut = 0;

    while (i < lines.count) {
        let is *ParsedLine as line = pl_get(lines, i);

        if (line.kind == LINE_INST) {
            let is enc.Operand as o1 = make_op(line, 1);
            let is enc.Operand as o2 = make_op(line, 2);

            // Resolve label targets
            let is i64 as resolve1 with mut = 0;

            if (line.op1_kind == enc.OP_LABEL) {
                let is i32 as idx = elf.sym_find(symtab, line.op1_label_ptr, line.op1_label_len);
                if (idx != 99999) {
                    let is *elf.Symbol as sym = elf.sym_get(symtab, idx);
                    if (sym.section == SECTION_TEXT) {
                        resolve1 = sym.offset;
                    } else {
                        resolve1 = 0;
                    }
                } else {
                    let is i32 as new_idx = elf.sym_find_or_add(symtab, line.op1_label_ptr, line.op1_label_len, SECTION_UNDEF, 0, 0);
                    resolve1 = 0;
                }
            }

            if (line.op1_kind == enc.OP_RIP_LABEL || line.op2_kind == enc.OP_RIP_LABEL) {
                // RIP-relative — need relocation
                let is *u8 as lab_ptr with mut = cast(*u8, 0);
                let is i32 as lab_len with mut = 0;
                if (line.op1_kind == enc.OP_RIP_LABEL) {
                    lab_ptr = line.op1_label_ptr;
                    lab_len = line.op1_label_len;
                } else {
                    lab_ptr = line.op2_label_ptr;
                    lab_len = line.op2_label_len;
                }
                let is i32 as sym_idx = elf.sym_find_or_add(symtab, lab_ptr, lab_len, SECTION_UNDEF, 0, 0);
                // Encode to a temp buffer to find the size
                let is enc.ByteBuffer as tmp = enc.buf_init(32);
                let is i32 as sz = enc.encode(&tmp, line.inst_id, &o1, &o2, 0, line.offset);
                mem.gfree(tmp.data);
                // The rel32 is at the last 4 bytes of the instruction
                let is i64 as reloc_off = line.offset + cast(i64, sz) - 4;
                elf.reloc_add(relocs, reloc_off, cast(i64, sym_idx), elf.R_X86_64_PC32, 0 - 4);

                // Encode with resolve_label = 0 (relocation will fix it)
                enc.encode(text_buf, line.inst_id, &o1, &o2, 0, line.offset);
            } else {
                enc.encode(text_buf, line.inst_id, &o1, &o2, resolve1, line.offset);
            }
        }
        else if (line.kind == LINE_DIRECTIVE) {
            let is *enc.ByteBuffer as target with mut = text_buf;
            if (line.section == SECTION_DATA)   { target = data_buf; }
            if (line.section == SECTION_RODATA) { target = rodata_buf; }

            if (line.dir_kind == DIR_STRING) {
                let is i32 as decoded_len with mut = 0;
                let is *u8 as decoded = decode_string(line.dir_arg_ptr, line.dir_arg_len, &decoded_len);
                enc.buf_append(target, decoded, cast(i64, decoded_len));
                enc.buf_emit8(target, 0); // null terminator
                mem.gfree(decoded);
            }
            else if (line.dir_kind == DIR_BYTE) {
                enc.buf_emit8(target, cast(i32, line.dir_num));
            }
            else if (line.dir_kind == DIR_WORD) {
                enc.buf_emit16_le(target, cast(i32, line.dir_num));
            }
            else if (line.dir_kind == DIR_LONG) {
                enc.buf_emit32_le(target, line.dir_num);
            }
            else if (line.dir_kind == DIR_QUAD) {
                enc.buf_emit64_le(target, line.dir_num);
            }
            else if (line.dir_kind == DIR_ZERO) {
                if (line.section == SECTION_BSS) {
                    *bss_size = *bss_size + line.dir_num;
                } else {
                    let is i64 as zi with mut = 0;
                    while (zi < line.dir_num) {
                        enc.buf_emit8(target, 0);
                        zi = zi + 1;
                    }
                }
            }
        }
        i = i + 1;
    }
}

// === Minimal I/O helpers ===
fn strlen(s as *u8) as i64 {
    let is i64 as i with mut = 0;
    while (s[i] != 0) { i = i + 1; }
    return i;
}

fn print_str(s as *u8) as void {
    linux.write(linux.STDOUT, s, strlen(s));
}

fn print_int(n as i64) as void {
    if (n == 0) { linux.write(linux.STDOUT, "0", 1); return; }
    let is [24]u8 as buf;
    let is i64 as val with mut = n;
    let is i64 as neg with mut = 0;
    if (val < 0) { neg = 1; val = 0 - val; }
    let is i32 as pos with mut = 23;
    while (val > 0) {
        buf[pos] = cast(u8, (val % 10) + 48);
        val = val / 10;
        pos = pos - 1;
    }
    if (neg == 1) { buf[pos] = 45; pos = pos - 1; }
    let is i64 as start = cast(i64, pos) + 1;
    linux.write(linux.STDOUT, cast(*u8, cast(i64, &buf) + start), 24 - start);
}

fn read_file(path as *u8) as *u8 {
    let is i64 as fd = linux.open(path, linux.O_RDONLY, 0);
    if (fd < 0) { return cast(*u8, 0); }
    let is i64 as size = linux.lseek(fd, 0, linux.SEEK_END);
    linux.lseek(fd, 0, linux.SEEK_SET);
    if (size <= 0) { linux.close(fd); return cast(*u8, 0); }
    let is *u8 as buf = mem.galloc(size + 1);
    linux.read(fd, buf, size);
    buf[size] = cast(u8, 0);
    linux.close(fd);
    return buf;
}

fn read_file_size(path as *u8) as i64 {
    let is i64 as fd = linux.open(path, linux.O_RDONLY, 0);
    if (fd < 0) { return 0; }
    let is i64 as size = linux.lseek(fd, 0, linux.SEEK_END);
    linux.close(fd);
    return size;
}

fn make_output_name(input as *u8) as *u8 {
    let is i64 as len = strlen(input);
    let is *u8 as out = mem.galloc(len + 3);
    mem.memcpy(out, input, len);
    out[len] = 46;     // '.'
    out[len + 1] = 111; // 'o'
    out[len + 2] = 0;
    return out;
}

fn main(argc as i64, argv as i64) as i32 {
    if (argc < 2) {
        linux.write(linux.STDERR, "Usage: caustic-as <input.s>\n", 28);
        return 1;
    }

    mem.gheapinit(4194304); // 4MB heap

    // Get filename from argv[1]
    let is *i64 as argv_arr = cast(*i64, argv);
    let is *u8 as filename = cast(*u8, argv_arr[1]);

    // Read file
    let is i64 as file_size = read_file_size(filename);
    let is *u8 as src = read_file(filename);
    if (cast(i64, src) == 0) {
        linux.write(linux.STDERR, "Error: cannot read file\n", 24);
        return 1;
    }

    print_str("caustic-as: assembling ");
    print_str(filename);
    print_str(" (");
    print_int(file_size);
    print_str(" bytes)\n");

    // Tokenize
    let is lex.TokenList as tokens = lex.tokenize(src, file_size);
    print_str("  tokens: ");
    print_int(cast(i64, tokens.count));
    print_str("\n");

    // Parse
    let is ParsedLines as lines = parse_all(&tokens);
    print_str("  lines: ");
    print_int(cast(i64, lines.count));
    print_str("\n");

    // Pass 1: collect symbols, calculate sizes
    let is elf.SymbolTable as symtab = elf.sym_init();
    pass1(&lines, &symtab);
    print_str("  symbols: ");
    print_int(cast(i64, symtab.count));
    print_str("\n");

    // Pass 2: encode
    let is enc.ByteBuffer as text_buf = enc.buf_init(65536);
    let is enc.ByteBuffer as data_buf = enc.buf_init(4096);
    let is enc.ByteBuffer as rodata_buf = enc.buf_init(4096);
    let is i64 as bss_size with mut = 0;
    let is elf.RelocList as relocs = elf.reloc_init();

    pass2(&lines, &symtab, &text_buf, &data_buf, &rodata_buf, &bss_size, &relocs);
    print_str("  .text: ");
    print_int(text_buf.len);
    print_str(" bytes\n");
    print_str("  .data: ");
    print_int(data_buf.len);
    print_str(" bytes\n");
    print_str("  .rodata: ");
    print_int(rodata_buf.len);
    print_str(" bytes\n");
    print_str("  .bss: ");
    print_int(bss_size);
    print_str(" bytes\n");
    print_str("  relocations: ");
    print_int(cast(i64, relocs.count));
    print_str("\n");

    // Build output filename: input + ".o"
    let is *u8 as out_name = make_output_name(filename);

    // Open output file
    let is i64 as fd = linux.open(out_name, 577, 420); // O_WRONLY|O_CREAT|O_TRUNC, 0644
    if (fd < 0) {
        linux.write(linux.STDERR, "Error: cannot create output\n", 28);
        return 1;
    }

    // Write ELF
    elf.write_elf(fd, &text_buf, &data_buf, &rodata_buf, bss_size, &symtab, &relocs);
    linux.close(fd);

    print_str("  output: ");
    print_str(out_name);
    print_str("\n");
    return 0;
}
