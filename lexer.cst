use "../std/mem.cst" as mem;
use "../std/linux.cst" as linux;
use "encoder.cst" as enc;

// Token kinds
let is i32 as TK_EOF with imut = 0;
let is i32 as TK_NEWLINE with imut = 1;
let is i32 as TK_IDENT with imut = 2;
let is i32 as TK_NUMBER with imut = 3;
let is i32 as TK_STRING with imut = 4;
let is i32 as TK_COMMA with imut = 5;
let is i32 as TK_COLON with imut = 6;
let is i32 as TK_LBRACKET with imut = 7;
let is i32 as TK_RBRACKET with imut = 8;
let is i32 as TK_PLUS with imut = 9;
let is i32 as TK_MINUS with imut = 10;
let is i32 as TK_STAR with imut = 11;
let is i32 as TK_REGISTER with imut = 13;
let is i32 as TK_INSTRUCTION with imut = 14;
let is i32 as TK_DIRECTIVE with imut = 15;
let is i32 as TK_SIZE_PREFIX with imut = 16;

struct Token {
    kind as i32;
    ptr as *u8;
    len as i32;
    line as i32;
    num_val as i64;
    reg_id as i32;
    inst_id as i32;
    size_val as i32;
}

struct TokenList {
    data as *u8;
    count as i32;
    cap as i32;
}

fn tl_init() as TokenList {
    let is i32 as cap = 8192;
    let is TokenList as tl;
    tl.data = mem.galloc(cast(i64, cap) * sizeof(Token));
    tl.count = 0;
    tl.cap = cap;
    return tl;
}

fn tl_push(tl as *TokenList, tok as Token) as void {
    if (tl.count >= tl.cap) {
        let is i32 as new_cap = tl.cap * 2;
        let is *u8 as new_data = mem.galloc(cast(i64, new_cap) * sizeof(Token));
        mem.memcpy(new_data, tl.data, cast(i64, tl.count) * sizeof(Token));
        mem.gfree(tl.data);
        tl.data = new_data;
        tl.cap = new_cap;
    }
    let is *Token as slot = cast(*Token, cast(i64, tl.data) + cast(i64, tl.count) * sizeof(Token));
    slot.kind = tok.kind;
    slot.ptr = tok.ptr;
    slot.len = tok.len;
    slot.line = tok.line;
    slot.num_val = tok.num_val;
    slot.reg_id = tok.reg_id;
    slot.inst_id = tok.inst_id;
    slot.size_val = tok.size_val;
    tl.count = tl.count + 1;
}

fn tl_get(tl as *TokenList, idx as i32) as *Token {
    return cast(*Token, cast(i64, tl.data) + cast(i64, idx) * sizeof(Token));
}

fn make_tok(kind as i32, ptr as *u8, len as i32, line as i32) as Token {
    let is Token as t;
    t.kind = kind;
    t.ptr = ptr;
    t.len = len;
    t.line = line;
    t.num_val = 0;
    t.reg_id = enc.REG_NONE;
    t.inst_id = enc.INST_NONE;
    t.size_val = 0;
    return t;
}

fn is_alpha(c as u8) as i32 {
    if (c >= 65 && c <= 90) { return 1; }
    if (c >= 97 && c <= 122) { return 1; }
    if (c == 95) { return 1; }
    return 0;
}

fn is_digit(c as u8) as i32 {
    if (c >= 48 && c <= 57) { return 1; }
    return 0;
}

fn is_alnum(c as u8) as i32 {
    if (is_alpha(c) == 1) { return 1; }
    if (is_digit(c) == 1) { return 1; }
    return 0;
}

fn parse_number(src as *u8, pos as i64, src_len as i64) as i64 {
    // Returns the parsed number value
    // The caller advances pos by counting digits
    let is i64 as i with mut = pos;
    let is i64 as result with mut = 0;

    // Hex: 0x...
    if (i + 1 < src_len && src[i] == 48 && (src[i + 1] == 120 || src[i + 1] == 88)) {
        i = i + 2;
        while (i < src_len) {
            let is u8 as c = src[i];
            if (c >= 48 && c <= 57) {
                result = result * 16 + cast(i64, c) - 48;
            } else if (c >= 97 && c <= 102) {
                result = result * 16 + cast(i64, c) - 87;
            } else if (c >= 65 && c <= 70) {
                result = result * 16 + cast(i64, c) - 55;
            } else {
                break;
            }
            i = i + 1;
        }
        return result;
    }

    // Decimal
    while (i < src_len && is_digit(src[i]) == 1) {
        result = result * 10 + cast(i64, src[i]) - 48;
        i = i + 1;
    }
    return result;
}

fn count_number_len(src as *u8, pos as i64, src_len as i64) as i32 {
    let is i64 as i with mut = pos;
    if (i + 1 < src_len && src[i] == 48 && (src[i + 1] == 120 || src[i + 1] == 88)) {
        i = i + 2;
        while (i < src_len) {
            let is u8 as c = src[i];
            if ((c >= 48 && c <= 57) || (c >= 97 && c <= 102) || (c >= 65 && c <= 70)) {
                i = i + 1;
            } else {
                break;
            }
        }
        return cast(i32, i - pos);
    }
    while (i < src_len && is_digit(src[i]) == 1) {
        i = i + 1;
    }
    return cast(i32, i - pos);
}

fn tokenize(src as *u8, src_len as i64) as TokenList {
    let is TokenList as tl = tl_init();
    let is i64 as i with mut = 0;
    let is i32 as line with mut = 1;

    while (i < src_len) {
        let is u8 as c = src[i];

        // Skip whitespace (not newline)
        if (c == 32 || c == 9 || c == 13) {
            i = i + 1;
        }
        // Newline
        else if (c == 10) {
            let is Token as t = make_tok(TK_NEWLINE, cast(*u8, cast(i64, src) + i), 1, line);
            tl_push(&tl, t);
            line = line + 1;
            i = i + 1;
        }
        // Comment: # or //
        else if (c == 35) {
            while (i < src_len && src[i] != 10) { i = i + 1; }
        }
        else if (c == 47 && i + 1 < src_len && src[i + 1] == 47) {
            while (i < src_len && src[i] != 10) { i = i + 1; }
        }
        // String literal
        else if (c == 34) {
            let is i64 as start = i;
            i = i + 1;
            while (i < src_len && src[i] != 34) {
                if (src[i] == 92) { i = i + 1; }
                i = i + 1;
            }
            if (i < src_len) { i = i + 1; }
            let is Token as t = make_tok(TK_STRING, cast(*u8, cast(i64, src) + start), cast(i32, i - start), line);
            tl_push(&tl, t);
        }
        // Punctuation
        else if (c == 44) { let is Token as t = make_tok(TK_COMMA, cast(*u8, cast(i64, src) + i), 1, line); tl_push(&tl, t); i = i + 1; }
        else if (c == 58) { let is Token as t = make_tok(TK_COLON, cast(*u8, cast(i64, src) + i), 1, line); tl_push(&tl, t); i = i + 1; }
        else if (c == 91) { let is Token as t = make_tok(TK_LBRACKET, cast(*u8, cast(i64, src) + i), 1, line); tl_push(&tl, t); i = i + 1; }
        else if (c == 93) { let is Token as t = make_tok(TK_RBRACKET, cast(*u8, cast(i64, src) + i), 1, line); tl_push(&tl, t); i = i + 1; }
        else if (c == 43) { let is Token as t = make_tok(TK_PLUS, cast(*u8, cast(i64, src) + i), 1, line); tl_push(&tl, t); i = i + 1; }
        else if (c == 42) { let is Token as t = make_tok(TK_STAR, cast(*u8, cast(i64, src) + i), 1, line); tl_push(&tl, t); i = i + 1; }
        // Minus sign or negative number
        else if (c == 45) {
            let is Token as t = make_tok(TK_MINUS, cast(*u8, cast(i64, src) + i), 1, line);
            tl_push(&tl, t);
            i = i + 1;
        }
        // Number
        else if (is_digit(c) == 1) {
            let is i64 as start = i;
            let is i64 as val = parse_number(src, i, src_len);
            let is i32 as nlen = count_number_len(src, i, src_len);
            let is Token as t = make_tok(TK_NUMBER, cast(*u8, cast(i64, src) + start), nlen, line);
            t.num_val = val;
            tl_push(&tl, t);
            i = i + cast(i64, nlen);
        }
        // Dot: directive or label part
        else if (c == 46) {
            let is i64 as start = i;
            i = i + 1;
            while (i < src_len && (is_alnum(src[i]) == 1 || src[i] == 46)) {
                i = i + 1;
            }
            let is i32 as tlen = cast(i32, i - start);
            let is *u8 as tptr = cast(*u8, cast(i64, src) + start);

            // Check if it's a known directive
            if (enc.streq_lit(tptr, tlen, ".intel_syntax") == 1 ||
                enc.streq_lit(tptr, tlen, ".text") == 1 ||
                enc.streq_lit(tptr, tlen, ".data") == 1 ||
                enc.streq_lit(tptr, tlen, ".rodata") == 1 ||
                enc.streq_lit(tptr, tlen, ".bss") == 1 ||
                enc.streq_lit(tptr, tlen, ".globl") == 1 ||
                enc.streq_lit(tptr, tlen, ".global") == 1 ||
                enc.streq_lit(tptr, tlen, ".section") == 1 ||
                enc.streq_lit(tptr, tlen, ".string") == 1 ||
                enc.streq_lit(tptr, tlen, ".byte") == 1 ||
                enc.streq_lit(tptr, tlen, ".word") == 1 ||
                enc.streq_lit(tptr, tlen, ".long") == 1 ||
                enc.streq_lit(tptr, tlen, ".quad") == 1 ||
                enc.streq_lit(tptr, tlen, ".zero") == 1 ||
                enc.streq_lit(tptr, tlen, ".ascii") == 1 ||
                enc.streq_lit(tptr, tlen, ".asciz") == 1 ||
                enc.streq_lit(tptr, tlen, ".value") == 1) {
                let is Token as t = make_tok(TK_DIRECTIVE, tptr, tlen, line);
                tl_push(&tl, t);
            } else {
                // Local label like .L0, .LC0
                let is Token as t = make_tok(TK_IDENT, tptr, tlen, line);
                tl_push(&tl, t);
            }
        }
        // Identifier
        else if (is_alpha(c) == 1) {
            let is i64 as start = i;
            while (i < src_len && (is_alnum(src[i]) == 1 || src[i] == 46)) {
                i = i + 1;
            }
            let is i32 as tlen = cast(i32, i - start);
            let is *u8 as tptr = cast(*u8, cast(i64, src) + start);

            // Check: size prefix?
            if (enc.streq_lit(tptr, tlen, "QWORD") == 1) {
                // Consume " PTR"
                let is i64 as save_i = i;
                // skip spaces
                while (i < src_len && src[i] == 32) { i = i + 1; }
                if (i + 3 <= src_len && src[i] == 80 && src[i+1] == 84 && src[i+2] == 82) {
                    i = i + 3;
                    let is Token as t = make_tok(TK_SIZE_PREFIX, tptr, cast(i32, i - start), line);
                    t.size_val = 64;
                    tl_push(&tl, t);
                } else {
                    i = save_i;
                    let is Token as t = make_tok(TK_IDENT, tptr, tlen, line);
                    tl_push(&tl, t);
                }
            }
            else if (enc.streq_lit(tptr, tlen, "DWORD") == 1) {
                let is i64 as save_i = i;
                while (i < src_len && src[i] == 32) { i = i + 1; }
                if (i + 3 <= src_len && src[i] == 80 && src[i+1] == 84 && src[i+2] == 82) {
                    i = i + 3;
                    let is Token as t = make_tok(TK_SIZE_PREFIX, tptr, cast(i32, i - start), line);
                    t.size_val = 32;
                    tl_push(&tl, t);
                } else {
                    i = save_i;
                    let is Token as t = make_tok(TK_IDENT, tptr, tlen, line);
                    tl_push(&tl, t);
                }
            }
            else if (enc.streq_lit(tptr, tlen, "WORD") == 1) {
                let is i64 as save_i = i;
                while (i < src_len && src[i] == 32) { i = i + 1; }
                if (i + 3 <= src_len && src[i] == 80 && src[i+1] == 84 && src[i+2] == 82) {
                    i = i + 3;
                    let is Token as t = make_tok(TK_SIZE_PREFIX, tptr, cast(i32, i - start), line);
                    t.size_val = 16;
                    tl_push(&tl, t);
                } else {
                    i = save_i;
                    let is Token as t = make_tok(TK_IDENT, tptr, tlen, line);
                    tl_push(&tl, t);
                }
            }
            else if (enc.streq_lit(tptr, tlen, "BYTE") == 1) {
                let is i64 as save_i = i;
                while (i < src_len && src[i] == 32) { i = i + 1; }
                if (i + 3 <= src_len && src[i] == 80 && src[i+1] == 84 && src[i+2] == 82) {
                    i = i + 3;
                    let is Token as t = make_tok(TK_SIZE_PREFIX, tptr, cast(i32, i - start), line);
                    t.size_val = 8;
                    tl_push(&tl, t);
                } else {
                    i = save_i;
                    let is Token as t = make_tok(TK_IDENT, tptr, tlen, line);
                    tl_push(&tl, t);
                }
            }
            else {
                // Check register
                let is i32 as reg = enc.lookup_register(tptr, tlen);
                if (reg != enc.REG_NONE) {
                    let is Token as t = make_tok(TK_REGISTER, tptr, tlen, line);
                    t.reg_id = reg;
                    tl_push(&tl, t);
                } else {
                    // Check instruction
                    let is i32 as inst = enc.lookup_instruction(tptr, tlen);
                    if (inst != enc.INST_NONE) {
                        let is Token as t = make_tok(TK_INSTRUCTION, tptr, tlen, line);
                        t.inst_id = inst;
                        tl_push(&tl, t);
                    } else {
                        // Check if it's "noprefix" or "PTR" leftover
                        if (enc.streq_lit(tptr, tlen, "noprefix") == 1 || enc.streq_lit(tptr, tlen, "PTR") == 1) {
                            // skip
                        } else {
                            let is Token as t = make_tok(TK_IDENT, tptr, tlen, line);
                            tl_push(&tl, t);
                        }
                    }
                }
            }
        }
        else {
            // Unknown char, skip
            i = i + 1;
        }
    }

    // Add EOF
    let is Token as eof = make_tok(TK_EOF, cast(*u8, 0), 0, line);
    tl_push(&tl, eof);
    return tl;
}
