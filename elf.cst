use "../std/mem.cst" as mem;
use "../std/linux.cst" as linux;
use "encoder.cst" as enc;

// ELF constants
let is i32 as ET_REL with imut = 1;
let is i32 as EM_X86_64 with imut = 62;
let is i32 as SHT_NULL with imut = 0;
let is i32 as SHT_PROGBITS with imut = 1;
let is i32 as SHT_SYMTAB with imut = 2;
let is i32 as SHT_STRTAB with imut = 3;
let is i32 as SHT_RELA with imut = 4;
let is i32 as SHT_NOBITS with imut = 8;
let is i32 as SHF_WRITE with imut = 1;
let is i32 as SHF_ALLOC with imut = 2;
let is i32 as SHF_EXECINSTR with imut = 4;
let is i32 as STB_LOCAL with imut = 0;
let is i32 as STB_GLOBAL with imut = 1;
let is i32 as STT_NOTYPE with imut = 0;
let is i32 as STT_OBJECT with imut = 1;
let is i32 as STT_FUNC with imut = 2;
let is i32 as STT_SECTION with imut = 3;
let is i64 as R_X86_64_PC32 with imut = 2;
let is i64 as R_X86_64_PLT32 with imut = 4;

// Symbol
struct Symbol {
    name_ptr as *u8;
    name_len as i32;
    section as i32;
    offset as i64;
    is_global as i32;
    strtab_off as i32;
}

struct SymbolTable {
    data as *u8;
    count as i32;
    cap as i32;
}

fn sym_init() as SymbolTable {
    let is i32 as cap = 1024;
    let is SymbolTable as st;
    st.data = mem.galloc(cast(i64, cap) * sizeof(Symbol));
    st.count = 0;
    st.cap = cap;
    return st;
}

fn sym_get(st as *SymbolTable, idx as i32) as *Symbol {
    return cast(*Symbol, cast(i64, st.data) + cast(i64, idx) * sizeof(Symbol));
}

fn sym_add(st as *SymbolTable, name_ptr as *u8, name_len as i32, section as i32, offset as i64, is_global as i32) as void {
    if (st.count >= st.cap) {
        let is i32 as new_cap = st.cap * 2;
        let is *u8 as new_data = mem.galloc(cast(i64, new_cap) * sizeof(Symbol));
        mem.memcpy(new_data, st.data, cast(i64, st.count) * sizeof(Symbol));
        mem.gfree(st.data);
        st.data = new_data;
        st.cap = new_cap;
    }
    let is *Symbol as s = sym_get(st, st.count);
    s.name_ptr = name_ptr;
    s.name_len = name_len;
    s.section = section;
    s.offset = offset;
    s.is_global = is_global;
    s.strtab_off = 0;
    st.count = st.count + 1;
}

fn sym_find(st as *SymbolTable, name_ptr as *u8, name_len as i32) as i32 {
    let is i32 as i with mut = 0;
    while (i < st.count) {
        let is *Symbol as s = sym_get(st, i);
        if (enc.streq(s.name_ptr, s.name_len, name_ptr, name_len) == 1) {
            return i;
        }
        i = i + 1;
    }
    return 99999;
}

fn sym_find_or_add(st as *SymbolTable, name_ptr as *u8, name_len as i32, section as i32, offset as i64, is_global as i32) as i32 {
    let is i32 as idx = sym_find(st, name_ptr, name_len);
    if (idx != 99999) {
        // Update if it was a forward reference
        let is *Symbol as s = sym_get(st, idx);
        if (s.section == 99 && section != 99) {
            s.section = section;
            s.offset = offset;
        }
        if (is_global == 1) { s.is_global = 1; }
        return idx;
    }
    sym_add(st, name_ptr, name_len, section, offset, is_global);
    return st.count - 1;
}

// Relocation entry
struct Reloc {
    offset as i64;
    sym_idx as i64;
    rtype as i64;
    addend as i64;
}

struct RelocList {
    data as *u8;
    count as i32;
    cap as i32;
}

fn reloc_init() as RelocList {
    let is i32 as cap = 256;
    let is RelocList as rl;
    rl.data = mem.galloc(cast(i64, cap) * sizeof(Reloc));
    rl.count = 0;
    rl.cap = cap;
    return rl;
}

fn reloc_get(rl as *RelocList, idx as i32) as *Reloc {
    return cast(*Reloc, cast(i64, rl.data) + cast(i64, idx) * sizeof(Reloc));
}

fn reloc_add(rl as *RelocList, offset as i64, sym_idx as i64, rtype as i64, addend as i64) as void {
    if (rl.count >= rl.cap) {
        let is i32 as new_cap = rl.cap * 2;
        let is *u8 as new_data = mem.galloc(cast(i64, new_cap) * sizeof(Reloc));
        mem.memcpy(new_data, rl.data, cast(i64, rl.count) * sizeof(Reloc));
        mem.gfree(rl.data);
        rl.data = new_data;
        rl.cap = new_cap;
    }
    let is *Reloc as r = reloc_get(rl, rl.count);
    r.offset = offset;
    r.sym_idx = sym_idx;
    r.rtype = rtype;
    r.addend = addend;
    rl.count = rl.count + 1;
}

// Write ELF64 relocatable object file
// Sections: null, .text, .data, .rodata, .bss, .symtab, .strtab, .rela.text, .shstrtab
fn write_elf(fd as i64, text_buf as *enc.ByteBuffer, data_buf as *enc.ByteBuffer,
             rodata_buf as *enc.ByteBuffer, bss_size as i64,
             symtab as *SymbolTable, relocs as *RelocList) as void {

    let is enc.ByteBuffer as out = enc.buf_init(65536);

    // Section indices
    let is i32 as SEC_NULL with mut = 0;
    let is i32 as SEC_TEXT with mut = 1;
    let is i32 as SEC_DATA with mut = 2;
    let is i32 as SEC_RODATA with mut = 3;
    let is i32 as SEC_BSS with mut = 4;
    let is i32 as SEC_SYMTAB with mut = 5;
    let is i32 as SEC_STRTAB with mut = 6;
    let is i32 as SEC_RELA with mut = 7;
    let is i32 as SEC_SHSTRTAB with mut = 8;
    let is i32 as NUM_SECTIONS = 9;

    // Build .shstrtab
    let is enc.ByteBuffer as shstrtab = enc.buf_init(256);
    enc.buf_emit8(&shstrtab, 0); // null byte at start
    // Record offsets of each name
    let is i32 as sh_text_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".text", 6);
    let is i32 as sh_data_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".data", 6);
    let is i32 as sh_rodata_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".rodata", 8);
    let is i32 as sh_bss_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".bss", 5);
    let is i32 as sh_symtab_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".symtab", 8);
    let is i32 as sh_strtab_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".strtab", 8);
    let is i32 as sh_rela_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".rela.text", 11);
    let is i32 as sh_shstrtab_name = cast(i32, shstrtab.len);
    enc.buf_append(&shstrtab, ".shstrtab", 10);

    // Build .strtab (for symbol names)
    let is enc.ByteBuffer as strtab = enc.buf_init(4096);
    enc.buf_emit8(&strtab, 0); // null byte at start

    // Build ELF symtab entries
    // First: null entry (24 bytes of zeros)
    // Then: section symbols for .text, .data, .rodata, .bss
    // Then: all user symbols
    let is enc.ByteBuffer as symtab_buf = enc.buf_init(4096);

    // Null symbol (24 bytes)
    let is i32 as sym_entry_size = 24;
    let is i32 as si with mut = 0;
    while (si < sym_entry_size) {
        enc.buf_emit8(&symtab_buf, 0);
        si = si + 1;
    }

    // Section symbols
    let is i32 as sec_sym_start = 1;
    let is i32 as sec_idx with mut = 0;
    while (sec_idx < 4) {
        // st_name = 0
        enc.buf_emit32_le(&symtab_buf, 0);
        // st_info = STT_SECTION | (STB_LOCAL << 4)
        enc.buf_emit8(&symtab_buf, STT_SECTION);
        // st_other = 0
        enc.buf_emit8(&symtab_buf, 0);
        // st_shndx = section index (1=text, 2=data, 3=rodata, 4=bss)
        enc.buf_emit16_le(&symtab_buf, sec_idx + 1);
        // st_value = 0
        enc.buf_emit64_le(&symtab_buf, 0);
        // st_size = 0
        enc.buf_emit64_le(&symtab_buf, 0);
        sec_idx = sec_idx + 1;
    }

    // Count local symbols first (for sh_info)
    let is i32 as num_locals with mut = 5; // null + 4 section symbols
    let is i32 as syi with mut = 0;
    while (syi < symtab.count) {
        let is *Symbol as s = sym_get(symtab, syi);
        if (s.is_global == 0) {
            num_locals = num_locals + 1;
        }
        syi = syi + 1;
    }

    // Add local symbols first, then globals
    // We need to build a mapping: original sym index -> ELF sym index
    let is *i32 as sym_map = cast(*i32, mem.galloc(cast(i64, symtab.count + 1) * 4));
    let is i32 as elf_sym_idx with mut = 5; // after null + 4 section syms

    // Pass 1: locals
    syi = 0;
    while (syi < symtab.count) {
        let is *Symbol as s = sym_get(symtab, syi);
        if (s.is_global == 0) {
            // Add string to strtab
            let is i32 as str_off = cast(i32, strtab.len);
            s.strtab_off = str_off;
            enc.buf_append(&strtab, s.name_ptr, cast(i64, s.name_len));
            enc.buf_emit8(&strtab, 0);

            // st_name
            enc.buf_emit32_le(&symtab_buf, cast(i64, str_off));
            // st_info: STT_NOTYPE | (STB_LOCAL << 4)
            enc.buf_emit8(&symtab_buf, STT_NOTYPE);
            // st_other
            enc.buf_emit8(&symtab_buf, 0);
            // st_shndx
            let is i32 as shndx = s.section + 1;
            if (s.section == 99) { shndx = 0; }
            enc.buf_emit16_le(&symtab_buf, shndx);
            // st_value
            enc.buf_emit64_le(&symtab_buf, s.offset);
            // st_size
            enc.buf_emit64_le(&symtab_buf, 0);

            // Record in our local mapping array using pointer arithmetic
            let is *i32 as map_slot = cast(*i32, cast(i64, sym_map) + cast(i64, syi) * 4);
            *map_slot = elf_sym_idx;
            elf_sym_idx = elf_sym_idx + 1;
        }
        syi = syi + 1;
    }

    // Pass 2: globals
    syi = 0;
    while (syi < symtab.count) {
        let is *Symbol as s = sym_get(symtab, syi);
        if (s.is_global == 1) {
            let is i32 as str_off = cast(i32, strtab.len);
            s.strtab_off = str_off;
            enc.buf_append(&strtab, s.name_ptr, cast(i64, s.name_len));
            enc.buf_emit8(&strtab, 0);

            enc.buf_emit32_le(&symtab_buf, cast(i64, str_off));
            // STT_FUNC for .text, STT_OBJECT for .data/.rodata/.bss
            let is i32 as sym_type with mut = STT_FUNC;
            if (s.section == 1 || s.section == 2 || s.section == 3) { sym_type = STT_OBJECT; }
            let is i32 as info = sym_type + STB_GLOBAL * 16;
            enc.buf_emit8(&symtab_buf, info);
            enc.buf_emit8(&symtab_buf, 0);
            let is i32 as shndx = s.section + 1;
            if (s.section == 99) { shndx = 0; }
            enc.buf_emit16_le(&symtab_buf, shndx);
            enc.buf_emit64_le(&symtab_buf, s.offset);
            enc.buf_emit64_le(&symtab_buf, 0);

            let is *i32 as map_slot = cast(*i32, cast(i64, sym_map) + cast(i64, syi) * 4);
            *map_slot = elf_sym_idx;
            elf_sym_idx = elf_sym_idx + 1;
        }
        syi = syi + 1;
    }

    // Build .rela.text
    let is enc.ByteBuffer as rela_buf = enc.buf_init(4096);
    let is i32 as ri with mut = 0;
    while (ri < relocs.count) {
        let is *Reloc as r = reloc_get(relocs, ri);
        // r_offset
        enc.buf_emit64_le(&rela_buf, r.offset);
        // r_info = (sym_idx << 32) | type
        let is i64 as mapped_idx = r.sym_idx;
        // Look up in sym_map if it's a user symbol
        if (r.sym_idx >= 0 && r.sym_idx < cast(i64, symtab.count)) {
            let is *i32 as map_slot = cast(*i32, cast(i64, sym_map) + r.sym_idx * 4);
            mapped_idx = cast(i64, *map_slot);
        }
        let is i64 as info = mapped_idx * 4294967296 + r.rtype;
        enc.buf_emit64_le(&rela_buf, info);
        // r_addend
        enc.buf_emit64_le(&rela_buf, r.addend);
        ri = ri + 1;
    }

    // Now compute layout
    let is i64 as elf_hdr_size = 64;
    let is i64 as sh_entry_size = 64;

    // Section data starts after ELF header
    let is i64 as off with mut = elf_hdr_size;

    // .text
    let is i64 as text_off = off;
    let is i64 as text_size = text_buf.len;
    off = off + text_size;
    // Align to 16
    if (off % 16 != 0) { off = off + 16 - (off % 16); }

    // .data
    let is i64 as data_off = off;
    let is i64 as data_size = data_buf.len;
    off = off + data_size;
    if (off % 16 != 0 && data_size > 0) { off = off + 16 - (off % 16); }

    // .rodata
    let is i64 as rodata_off = off;
    let is i64 as rodata_size = rodata_buf.len;
    off = off + rodata_size;
    if (off % 16 != 0 && rodata_size > 0) { off = off + 16 - (off % 16); }

    // .bss (no data in file)
    let is i64 as bss_off = off;

    // .symtab
    let is i64 as symtab_off = off;
    let is i64 as symtab_size = symtab_buf.len;
    off = off + symtab_size;
    if (off % 8 != 0) { off = off + 8 - (off % 8); }

    // .strtab
    let is i64 as strtab_off = off;
    let is i64 as strtab_size = strtab.len;
    off = off + strtab_size;

    // .rela.text
    if (off % 8 != 0 && rela_buf.len > 0) { off = off + 8 - (off % 8); }
    let is i64 as rela_off = off;
    let is i64 as rela_size = rela_buf.len;
    off = off + rela_size;

    // .shstrtab
    let is i64 as shstrtab_off = off;
    let is i64 as shstrtab_size = shstrtab.len;
    off = off + shstrtab_size;
    if (off % 8 != 0) { off = off + 8 - (off % 8); }

    // Section headers
    let is i64 as shdr_off = off;

    // === Write ELF header ===
    // Magic
    enc.buf_emit8(&out, 127); enc.buf_emit8(&out, 69); enc.buf_emit8(&out, 76); enc.buf_emit8(&out, 70);
    // Class (64-bit), Data (LE), Version, OS/ABI, padding
    enc.buf_emit8(&out, 2); enc.buf_emit8(&out, 1); enc.buf_emit8(&out, 1); enc.buf_emit8(&out, 0);
    enc.buf_emit64_le(&out, 0); // padding
    // e_type = ET_REL
    enc.buf_emit16_le(&out, ET_REL);
    // e_machine = EM_X86_64
    enc.buf_emit16_le(&out, EM_X86_64);
    // e_version
    enc.buf_emit32_le(&out, 1);
    // e_entry
    enc.buf_emit64_le(&out, 0);
    // e_phoff
    enc.buf_emit64_le(&out, 0);
    // e_shoff
    enc.buf_emit64_le(&out, shdr_off);
    // e_flags
    enc.buf_emit32_le(&out, 0);
    // e_ehsize
    enc.buf_emit16_le(&out, 64);
    // e_phentsize, e_phnum
    enc.buf_emit16_le(&out, 0);
    enc.buf_emit16_le(&out, 0);
    // e_shentsize
    enc.buf_emit16_le(&out, 64);
    // e_shnum
    enc.buf_emit16_le(&out, NUM_SECTIONS);
    // e_shstrndx
    enc.buf_emit16_le(&out, SEC_SHSTRTAB);

    // === Write section data ===
    // .text
    enc.buf_append(&out, text_buf.data, text_size);
    enc.buf_align(&out, 16);
    // .data
    if (data_size > 0) {
        enc.buf_append(&out, data_buf.data, data_size);
        enc.buf_align(&out, 16);
    }
    // .rodata
    if (rodata_size > 0) {
        enc.buf_append(&out, rodata_buf.data, rodata_size);
        enc.buf_align(&out, 16);
    }
    // .symtab
    enc.buf_append(&out, symtab_buf.data, symtab_size);
    enc.buf_align(&out, 8);
    // .strtab
    enc.buf_append(&out, strtab.data, strtab_size);
    // .rela.text
    if (rela_size > 0) {
        enc.buf_align(&out, 8);
        enc.buf_append(&out, rela_buf.data, rela_size);
    }
    // .shstrtab
    enc.buf_append(&out, shstrtab.data, shstrtab_size);
    enc.buf_align(&out, 8);

    // === Write section headers ===
    // Helper: write one section header (64 bytes)
    // 0: SHT_NULL
    let is i32 as shi with mut = 0;
    while (shi < 64) { enc.buf_emit8(&out, 0); shi = shi + 1; }

    // 1: .text
    enc.buf_emit32_le(&out, cast(i64, sh_text_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_PROGBITS));
    enc.buf_emit64_le(&out, cast(i64, SHF_ALLOC + SHF_EXECINSTR));
    enc.buf_emit64_le(&out, 0); // addr
    enc.buf_emit64_le(&out, text_off);
    enc.buf_emit64_le(&out, text_size);
    enc.buf_emit32_le(&out, 0); // link
    enc.buf_emit32_le(&out, 0); // info
    enc.buf_emit64_le(&out, 16); // addralign
    enc.buf_emit64_le(&out, 0); // entsize

    // 2: .data
    enc.buf_emit32_le(&out, cast(i64, sh_data_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_PROGBITS));
    enc.buf_emit64_le(&out, cast(i64, SHF_ALLOC + SHF_WRITE));
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, data_off);
    enc.buf_emit64_le(&out, data_size);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit64_le(&out, 8);
    enc.buf_emit64_le(&out, 0);

    // 3: .rodata
    enc.buf_emit32_le(&out, cast(i64, sh_rodata_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_PROGBITS));
    enc.buf_emit64_le(&out, cast(i64, SHF_ALLOC));
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, rodata_off);
    enc.buf_emit64_le(&out, rodata_size);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit64_le(&out, 1);
    enc.buf_emit64_le(&out, 0);

    // 4: .bss
    enc.buf_emit32_le(&out, cast(i64, sh_bss_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_NOBITS));
    enc.buf_emit64_le(&out, cast(i64, SHF_ALLOC + SHF_WRITE));
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, bss_off);
    enc.buf_emit64_le(&out, bss_size);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit64_le(&out, 8);
    enc.buf_emit64_le(&out, 0);

    // 5: .symtab
    enc.buf_emit32_le(&out, cast(i64, sh_symtab_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_SYMTAB));
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, symtab_off);
    enc.buf_emit64_le(&out, symtab_size);
    enc.buf_emit32_le(&out, cast(i64, SEC_STRTAB)); // link = .strtab
    enc.buf_emit32_le(&out, cast(i64, num_locals)); // info = first global sym idx
    enc.buf_emit64_le(&out, 8);
    enc.buf_emit64_le(&out, 24); // entsize

    // 6: .strtab
    enc.buf_emit32_le(&out, cast(i64, sh_strtab_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_STRTAB));
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, strtab_off);
    enc.buf_emit64_le(&out, strtab_size);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit64_le(&out, 1);
    enc.buf_emit64_le(&out, 0);

    // 7: .rela.text
    enc.buf_emit32_le(&out, cast(i64, sh_rela_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_RELA));
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, rela_off);
    enc.buf_emit64_le(&out, rela_size);
    enc.buf_emit32_le(&out, cast(i64, SEC_SYMTAB)); // link = .symtab
    enc.buf_emit32_le(&out, cast(i64, SEC_TEXT));    // info = .text section
    enc.buf_emit64_le(&out, 8);
    enc.buf_emit64_le(&out, 24); // entsize

    // 8: .shstrtab
    enc.buf_emit32_le(&out, cast(i64, sh_shstrtab_name));
    enc.buf_emit32_le(&out, cast(i64, SHT_STRTAB));
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, 0);
    enc.buf_emit64_le(&out, shstrtab_off);
    enc.buf_emit64_le(&out, shstrtab_size);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit32_le(&out, 0);
    enc.buf_emit64_le(&out, 1);
    enc.buf_emit64_le(&out, 0);

    // Write to file
    linux.write(fd, out.data, out.len);
}
