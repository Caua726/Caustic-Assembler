use "../std/mem.cst" as mem;
use "../std/linux.cst" as linux;

// === Register IDs ===
// 64-bit: 0-15
let is i32 as REG_RAX with imut = 0;
let is i32 as REG_RCX with imut = 1;
let is i32 as REG_RDX with imut = 2;
let is i32 as REG_RBX with imut = 3;
let is i32 as REG_RSP with imut = 4;
let is i32 as REG_RBP with imut = 5;
let is i32 as REG_RSI with imut = 6;
let is i32 as REG_RDI with imut = 7;
let is i32 as REG_R8  with imut = 8;
let is i32 as REG_R9  with imut = 9;
let is i32 as REG_R10 with imut = 10;
let is i32 as REG_R11 with imut = 11;
let is i32 as REG_R12 with imut = 12;
let is i32 as REG_R13 with imut = 13;
let is i32 as REG_R14 with imut = 14;
let is i32 as REG_R15 with imut = 15;
// 32-bit: 16-31
let is i32 as REG_EAX with imut = 16;
let is i32 as REG_ECX with imut = 17;
let is i32 as REG_EDX with imut = 18;
let is i32 as REG_EBX with imut = 19;
let is i32 as REG_ESP with imut = 20;
let is i32 as REG_EBP with imut = 21;
let is i32 as REG_ESI with imut = 22;
let is i32 as REG_EDI with imut = 23;
let is i32 as REG_R8D  with imut = 24;
let is i32 as REG_R9D  with imut = 25;
let is i32 as REG_R10D with imut = 26;
let is i32 as REG_R11D with imut = 27;
let is i32 as REG_R12D with imut = 28;
let is i32 as REG_R13D with imut = 29;
let is i32 as REG_R14D with imut = 30;
let is i32 as REG_R15D with imut = 31;
// 16-bit: 32-47
let is i32 as REG_AX with imut = 32;
let is i32 as REG_CX with imut = 33;
let is i32 as REG_DX with imut = 34;
let is i32 as REG_BX with imut = 35;
let is i32 as REG_SP with imut = 36;
let is i32 as REG_BP with imut = 37;
let is i32 as REG_SI with imut = 38;
let is i32 as REG_DI with imut = 39;
let is i32 as REG_R8W  with imut = 40;
let is i32 as REG_R9W  with imut = 41;
let is i32 as REG_R10W with imut = 42;
let is i32 as REG_R11W with imut = 43;
let is i32 as REG_R12W with imut = 44;
let is i32 as REG_R13W with imut = 45;
let is i32 as REG_R14W with imut = 46;
let is i32 as REG_R15W with imut = 47;
// 8-bit: 48-63
let is i32 as REG_AL  with imut = 48;
let is i32 as REG_CL  with imut = 49;
let is i32 as REG_DL  with imut = 50;
let is i32 as REG_BL  with imut = 51;
let is i32 as REG_SPL with imut = 52;
let is i32 as REG_BPL with imut = 53;
let is i32 as REG_SIL with imut = 54;
let is i32 as REG_DIL with imut = 55;
let is i32 as REG_R8B  with imut = 56;
let is i32 as REG_R9B  with imut = 57;
let is i32 as REG_R10B with imut = 58;
let is i32 as REG_R11B with imut = 59;
let is i32 as REG_R12B with imut = 60;
let is i32 as REG_R13B with imut = 61;
let is i32 as REG_R14B with imut = 62;
let is i32 as REG_R15B with imut = 63;
// XMM: 64-79
let is i32 as REG_XMM0  with imut = 64;
let is i32 as REG_XMM1  with imut = 65;
let is i32 as REG_XMM2  with imut = 66;
let is i32 as REG_XMM3  with imut = 67;
let is i32 as REG_XMM4  with imut = 68;
let is i32 as REG_XMM5  with imut = 69;
let is i32 as REG_XMM6  with imut = 70;
let is i32 as REG_XMM7  with imut = 71;
let is i32 as REG_XMM8  with imut = 72;
let is i32 as REG_XMM9  with imut = 73;
let is i32 as REG_XMM10 with imut = 74;
let is i32 as REG_XMM11 with imut = 75;
let is i32 as REG_XMM12 with imut = 76;
let is i32 as REG_XMM13 with imut = 77;
let is i32 as REG_XMM14 with imut = 78;
let is i32 as REG_XMM15 with imut = 79;
let is i32 as REG_NONE  with imut = 255;

// === Instruction IDs ===
let is i32 as INST_MOV     with imut = 1;
let is i32 as INST_MOVSX   with imut = 2;
let is i32 as INST_MOVSXD  with imut = 3;
let is i32 as INST_MOVZX   with imut = 4;
let is i32 as INST_LEA     with imut = 5;
let is i32 as INST_ADD     with imut = 6;
let is i32 as INST_SUB     with imut = 7;
let is i32 as INST_IMUL    with imut = 8;
let is i32 as INST_IDIV    with imut = 9;
let is i32 as INST_CQO     with imut = 10;
let is i32 as INST_NEG     with imut = 11;
let is i32 as INST_AND     with imut = 12;
let is i32 as INST_OR      with imut = 13;
let is i32 as INST_XOR     with imut = 14;
let is i32 as INST_NOT     with imut = 15;
let is i32 as INST_SHL     with imut = 16;
let is i32 as INST_SHR     with imut = 17;
let is i32 as INST_SAR     with imut = 18;
let is i32 as INST_CMP     with imut = 19;
let is i32 as INST_TEST    with imut = 20;
let is i32 as INST_SETE    with imut = 21;
let is i32 as INST_SETNE   with imut = 22;
let is i32 as INST_SETL    with imut = 23;
let is i32 as INST_SETLE   with imut = 24;
let is i32 as INST_SETG    with imut = 25;
let is i32 as INST_SETGE   with imut = 26;
let is i32 as INST_SETB    with imut = 27;
let is i32 as INST_SETBE   with imut = 28;
let is i32 as INST_SETA    with imut = 29;
let is i32 as INST_SETAE   with imut = 30;
let is i32 as INST_PUSH    with imut = 31;
let is i32 as INST_POP     with imut = 32;
let is i32 as INST_CALL    with imut = 33;
let is i32 as INST_RET     with imut = 34;
let is i32 as INST_JMP     with imut = 35;
let is i32 as INST_JZ      with imut = 36;
let is i32 as INST_JNZ     with imut = 37;
let is i32 as INST_JE      with imut = 38;
let is i32 as INST_JNE     with imut = 39;
let is i32 as INST_JL      with imut = 40;
let is i32 as INST_JLE     with imut = 41;
let is i32 as INST_JG      with imut = 42;
let is i32 as INST_JGE     with imut = 43;
let is i32 as INST_JA      with imut = 44;
let is i32 as INST_JAE     with imut = 45;
let is i32 as INST_JB      with imut = 46;
let is i32 as INST_JBE     with imut = 47;
let is i32 as INST_SYSCALL with imut = 48;
let is i32 as INST_CLD     with imut = 49;
let is i32 as INST_REP     with imut = 50;
let is i32 as INST_MOVSB   with imut = 51;
let is i32 as INST_NOP     with imut = 52;
let is i32 as INST_MOVQ    with imut = 53;
let is i32 as INST_ADDSD   with imut = 54;
let is i32 as INST_SUBSD   with imut = 55;
let is i32 as INST_MULSD   with imut = 56;
let is i32 as INST_DIVSD   with imut = 57;
let is i32 as INST_XORPD   with imut = 58;
let is i32 as INST_CVTTSD2SI with imut = 59;
let is i32 as INST_CVTSI2SD  with imut = 60;
let is i32 as INST_CDQ     with imut = 61;
let is i32 as INST_NONE    with imut = 0;

// === Operand kinds ===
let is i32 as OP_NONE  with imut = 0;
let is i32 as OP_REG   with imut = 1;
let is i32 as OP_IMM   with imut = 2;
let is i32 as OP_MEM   with imut = 3;
let is i32 as OP_LABEL  with imut = 4;
let is i32 as OP_RIP_LABEL with imut = 5;

struct Operand {
    kind as i32;
    reg_id as i32;
    imm as i64;
    mem_base as i32;
    mem_disp as i64;
    mem_size as i32;
    label_ptr as *u8;
    label_len as i32;
}

fn operand_none() as Operand {
    let is Operand as op;
    op.kind = OP_NONE;
    op.reg_id = REG_NONE;
    op.imm = 0;
    op.mem_base = REG_NONE;
    op.mem_disp = 0;
    op.mem_size = 0;
    op.label_ptr = cast(*u8, 0);
    op.label_len = 0;
    return op;
}

fn operand_reg(id as i32) as Operand {
    let is Operand as op;
    op.kind = OP_REG;
    op.reg_id = id;
    op.imm = 0;
    op.mem_base = REG_NONE;
    op.mem_disp = 0;
    op.mem_size = 0;
    op.label_ptr = cast(*u8, 0);
    op.label_len = 0;
    return op;
}

fn operand_imm(val as i64) as Operand {
    let is Operand as op;
    op.kind = OP_IMM;
    op.reg_id = REG_NONE;
    op.imm = val;
    op.mem_base = REG_NONE;
    op.mem_disp = 0;
    op.mem_size = 0;
    op.label_ptr = cast(*u8, 0);
    op.label_len = 0;
    return op;
}

fn operand_mem(base as i32, disp as i64, size as i32) as Operand {
    let is Operand as op;
    op.kind = OP_MEM;
    op.reg_id = REG_NONE;
    op.imm = 0;
    op.mem_base = base;
    op.mem_disp = disp;
    op.mem_size = size;
    op.label_ptr = cast(*u8, 0);
    op.label_len = 0;
    return op;
}

fn operand_label(ptr as *u8, len as i32) as Operand {
    let is Operand as op;
    op.kind = OP_LABEL;
    op.reg_id = REG_NONE;
    op.imm = 0;
    op.mem_base = REG_NONE;
    op.mem_disp = 0;
    op.mem_size = 0;
    op.label_ptr = ptr;
    op.label_len = len;
    return op;
}

fn operand_rip_label(ptr as *u8, len as i32) as Operand {
    let is Operand as op;
    op.kind = OP_RIP_LABEL;
    op.reg_id = REG_NONE;
    op.imm = 0;
    op.mem_base = REG_NONE;
    op.mem_disp = 0;
    op.mem_size = 0;
    op.label_ptr = ptr;
    op.label_len = len;
    return op;
}

// === ByteBuffer ===
struct ByteBuffer {
    data as *u8;
    len as i64;
    cap as i64;
}

fn buf_init(cap as i64) as ByteBuffer {
    let is ByteBuffer as b;
    b.data = mem.galloc(cap);
    b.len = 0;
    b.cap = cap;
    return b;
}

fn buf_ensure(b as *ByteBuffer, needed as i64) as void {
    if (b.len + needed > b.cap) {
        let is i64 as new_cap = b.cap * 2;
        if (new_cap < b.len + needed) {
            new_cap = b.len + needed + 1024;
        }
        let is *u8 as new_data = mem.galloc(new_cap);
        mem.memcpy(new_data, b.data, b.len);
        mem.gfree(b.data);
        b.data = new_data;
        b.cap = new_cap;
    }
}

fn buf_emit8(b as *ByteBuffer, val as i32) as void {
    buf_ensure(b, 1);
    b.data[b.len] = cast(u8, val);
    b.len = b.len + 1;
}

fn buf_emit16_le(b as *ByteBuffer, val as i32) as void {
    buf_ensure(b, 2);
    b.data[b.len] = cast(u8, val & 255);
    b.data[b.len + 1] = cast(u8, (val >> 8) & 255);
    b.len = b.len + 2;
}

fn buf_emit32_le(b as *ByteBuffer, val as i64) as void {
    buf_ensure(b, 4);
    b.data[b.len]     = cast(u8, val & 255);
    b.data[b.len + 1] = cast(u8, (val >> 8) & 255);
    b.data[b.len + 2] = cast(u8, (val >> 16) & 255);
    b.data[b.len + 3] = cast(u8, (val >> 24) & 255);
    b.len = b.len + 4;
}

fn buf_emit64_le(b as *ByteBuffer, val as i64) as void {
    buf_ensure(b, 8);
    b.data[b.len]     = cast(u8, val & 255);
    b.data[b.len + 1] = cast(u8, (val >> 8) & 255);
    b.data[b.len + 2] = cast(u8, (val >> 16) & 255);
    b.data[b.len + 3] = cast(u8, (val >> 24) & 255);
    b.data[b.len + 4] = cast(u8, (val >> 32) & 255);
    b.data[b.len + 5] = cast(u8, (val >> 40) & 255);
    b.data[b.len + 6] = cast(u8, (val >> 48) & 255);
    b.data[b.len + 7] = cast(u8, (val >> 56) & 255);
    b.len = b.len + 8;
}

fn buf_patch32_le(b as *ByteBuffer, offset as i64, val as i64) as void {
    b.data[offset]     = cast(u8, val & 255);
    b.data[offset + 1] = cast(u8, (val >> 8) & 255);
    b.data[offset + 2] = cast(u8, (val >> 16) & 255);
    b.data[offset + 3] = cast(u8, (val >> 24) & 255);
}

fn buf_append(dst as *ByteBuffer, src as *u8, len as i64) as void {
    buf_ensure(dst, len);
    mem.memcpy(cast(*u8, cast(i64, dst.data) + dst.len), src, len);
    dst.len = dst.len + len;
}

fn buf_align(b as *ByteBuffer, align as i64) as void {
    while (b.len % align != 0) {
        buf_emit8(b, 0);
    }
}

// === Register helpers ===

fn reg_code(id as i32) as i32 {
    if (id >= 64) { return (id - 64) % 8; }
    return id % 8;
}

fn reg_ext(id as i32) as i32 {
    if (id < 0) { return 0; }
    if (id >= 64) {
        if ((id - 64) >= 8) { return 1; }
        return 0;
    }
    if ((id % 16) >= 8) { return 1; }
    return 0;
}

fn reg_size(id as i32) as i32 {
    if (id < 0) { return 0; }
    if (id < 16) { return 64; }
    if (id < 32) { return 32; }
    if (id < 48) { return 16; }
    if (id < 64) { return 8; }
    return 128;
}

fn reg_base(id as i32) as i32 {
    if (id < 0) { return id; }
    if (id >= 64) { return id; }
    return id % 16;
}

fn needs_rex_for_8bit(id as i32) as i32 {
    if (id >= 52 && id <= 55) { return 1; }
    return 0;
}

// === String helpers ===
fn streq(a as *u8, alen as i32, b as *u8, blen as i32) as i32 {
    if (alen != blen) { return 0; }
    let is i32 as i with mut = 0;
    while (i < alen) {
        if (a[i] != b[i]) { return 0; }
        i = i + 1;
    }
    return 1;
}

fn streq_lit(a as *u8, alen as i32, lit as *u8) as i32 {
    let is i32 as i with mut = 0;
    while (lit[i] != 0) {
        if (i >= alen) { return 0; }
        if (a[i] != lit[i]) { return 0; }
        i = i + 1;
    }
    return cast(i32, i == alen);
}

// === Register lookup ===
fn lookup_register(ptr as *u8, len as i32) as i32 {
    if (len == 2) {
        if (ptr[0] == 97) {
            if (ptr[1] == 108) { return REG_AL; }
            if (ptr[1] == 120) { return REG_AX; }
            if (ptr[1] == 104) { return REG_AL; }
        }
        if (ptr[0] == 99 && ptr[1] == 108) { return REG_CL; }
        if (ptr[0] == 99 && ptr[1] == 120) { return REG_CX; }
        if (ptr[0] == 100 && ptr[1] == 108) { return REG_DL; }
        if (ptr[0] == 100 && ptr[1] == 120) { return REG_DX; }
        if (ptr[0] == 98 && ptr[1] == 108) { return REG_BL; }
        if (ptr[0] == 98 && ptr[1] == 120) { return REG_BX; }
        if (ptr[0] == 115 && ptr[1] == 112) { return REG_SP; }
        if (ptr[0] == 98 && ptr[1] == 112) { return REG_BP; }
        if (ptr[0] == 115 && ptr[1] == 105) { return REG_SI; }
        if (ptr[0] == 100 && ptr[1] == 105) { return REG_DI; }
        if (ptr[0] == 114 && ptr[1] == 56) { return REG_R8; }
        if (ptr[0] == 114 && ptr[1] == 57) { return REG_R9; }
    }
    if (len == 3) {
        if (streq_lit(ptr, len, "rax") == 1) { return REG_RAX; }
        if (streq_lit(ptr, len, "rcx") == 1) { return REG_RCX; }
        if (streq_lit(ptr, len, "rdx") == 1) { return REG_RDX; }
        if (streq_lit(ptr, len, "rbx") == 1) { return REG_RBX; }
        if (streq_lit(ptr, len, "rsp") == 1) { return REG_RSP; }
        if (streq_lit(ptr, len, "rbp") == 1) { return REG_RBP; }
        if (streq_lit(ptr, len, "rsi") == 1) { return REG_RSI; }
        if (streq_lit(ptr, len, "rdi") == 1) { return REG_RDI; }
        if (streq_lit(ptr, len, "eax") == 1) { return REG_EAX; }
        if (streq_lit(ptr, len, "ecx") == 1) { return REG_ECX; }
        if (streq_lit(ptr, len, "edx") == 1) { return REG_EDX; }
        if (streq_lit(ptr, len, "ebx") == 1) { return REG_EBX; }
        if (streq_lit(ptr, len, "esp") == 1) { return REG_ESP; }
        if (streq_lit(ptr, len, "ebp") == 1) { return REG_EBP; }
        if (streq_lit(ptr, len, "esi") == 1) { return REG_ESI; }
        if (streq_lit(ptr, len, "edi") == 1) { return REG_EDI; }
        if (streq_lit(ptr, len, "r8d") == 1) { return REG_R8D; }
        if (streq_lit(ptr, len, "r9d") == 1) { return REG_R9D; }
        if (streq_lit(ptr, len, "r8w") == 1) { return REG_R8W; }
        if (streq_lit(ptr, len, "r9w") == 1) { return REG_R9W; }
        if (streq_lit(ptr, len, "r8b") == 1) { return REG_R8B; }
        if (streq_lit(ptr, len, "r9b") == 1) { return REG_R9B; }
        if (streq_lit(ptr, len, "r10") == 1) { return REG_R10; }
        if (streq_lit(ptr, len, "r11") == 1) { return REG_R11; }
        if (streq_lit(ptr, len, "r12") == 1) { return REG_R12; }
        if (streq_lit(ptr, len, "r13") == 1) { return REG_R13; }
        if (streq_lit(ptr, len, "r14") == 1) { return REG_R14; }
        if (streq_lit(ptr, len, "r15") == 1) { return REG_R15; }
        if (streq_lit(ptr, len, "spl") == 1) { return REG_SPL; }
        if (streq_lit(ptr, len, "bpl") == 1) { return REG_BPL; }
        if (streq_lit(ptr, len, "sil") == 1) { return REG_SIL; }
        if (streq_lit(ptr, len, "dil") == 1) { return REG_DIL; }
        if (streq_lit(ptr, len, "rip") == 1) { return 99; }
    }
    if (len == 4) {
        if (streq_lit(ptr, len, "r10d") == 1) { return REG_R10D; }
        if (streq_lit(ptr, len, "r11d") == 1) { return REG_R11D; }
        if (streq_lit(ptr, len, "r12d") == 1) { return REG_R12D; }
        if (streq_lit(ptr, len, "r13d") == 1) { return REG_R13D; }
        if (streq_lit(ptr, len, "r14d") == 1) { return REG_R14D; }
        if (streq_lit(ptr, len, "r15d") == 1) { return REG_R15D; }
        if (streq_lit(ptr, len, "r10w") == 1) { return REG_R10W; }
        if (streq_lit(ptr, len, "r11w") == 1) { return REG_R11W; }
        if (streq_lit(ptr, len, "r12w") == 1) { return REG_R12W; }
        if (streq_lit(ptr, len, "r13w") == 1) { return REG_R13W; }
        if (streq_lit(ptr, len, "r14w") == 1) { return REG_R14W; }
        if (streq_lit(ptr, len, "r15w") == 1) { return REG_R15W; }
        if (streq_lit(ptr, len, "r10b") == 1) { return REG_R10B; }
        if (streq_lit(ptr, len, "r11b") == 1) { return REG_R11B; }
        if (streq_lit(ptr, len, "r12b") == 1) { return REG_R12B; }
        if (streq_lit(ptr, len, "r13b") == 1) { return REG_R13B; }
        if (streq_lit(ptr, len, "r14b") == 1) { return REG_R14B; }
        if (streq_lit(ptr, len, "r15b") == 1) { return REG_R15B; }
        if (streq_lit(ptr, len, "xmm0") == 1) { return REG_XMM0; }
        if (streq_lit(ptr, len, "xmm1") == 1) { return REG_XMM1; }
        if (streq_lit(ptr, len, "xmm2") == 1) { return REG_XMM2; }
        if (streq_lit(ptr, len, "xmm3") == 1) { return REG_XMM3; }
        if (streq_lit(ptr, len, "xmm4") == 1) { return REG_XMM4; }
        if (streq_lit(ptr, len, "xmm5") == 1) { return REG_XMM5; }
        if (streq_lit(ptr, len, "xmm6") == 1) { return REG_XMM6; }
        if (streq_lit(ptr, len, "xmm7") == 1) { return REG_XMM7; }
        if (streq_lit(ptr, len, "xmm8") == 1) { return REG_XMM8; }
        if (streq_lit(ptr, len, "xmm9") == 1) { return REG_XMM9; }
    }
    if (len == 5) {
        if (streq_lit(ptr, len, "xmm10") == 1) { return REG_XMM10; }
        if (streq_lit(ptr, len, "xmm11") == 1) { return REG_XMM11; }
        if (streq_lit(ptr, len, "xmm12") == 1) { return REG_XMM12; }
        if (streq_lit(ptr, len, "xmm13") == 1) { return REG_XMM13; }
        if (streq_lit(ptr, len, "xmm14") == 1) { return REG_XMM14; }
        if (streq_lit(ptr, len, "xmm15") == 1) { return REG_XMM15; }
    }
    return REG_NONE;
}

// === Instruction lookup ===
fn lookup_instruction(ptr as *u8, len as i32) as i32 {
    if (len == 3) {
        if (streq_lit(ptr, len, "mov") == 1) { return INST_MOV; }
        if (streq_lit(ptr, len, "lea") == 1) { return INST_LEA; }
        if (streq_lit(ptr, len, "add") == 1) { return INST_ADD; }
        if (streq_lit(ptr, len, "sub") == 1) { return INST_SUB; }
        if (streq_lit(ptr, len, "cqo") == 1) { return INST_CQO; }
        if (streq_lit(ptr, len, "cdq") == 1) { return INST_CDQ; }
        if (streq_lit(ptr, len, "neg") == 1) { return INST_NEG; }
        if (streq_lit(ptr, len, "and") == 1) { return INST_AND; }
        if (streq_lit(ptr, len, "xor") == 1) { return INST_XOR; }
        if (streq_lit(ptr, len, "not") == 1) { return INST_NOT; }
        if (streq_lit(ptr, len, "shl") == 1) { return INST_SHL; }
        if (streq_lit(ptr, len, "shr") == 1) { return INST_SHR; }
        if (streq_lit(ptr, len, "sar") == 1) { return INST_SAR; }
        if (streq_lit(ptr, len, "cmp") == 1) { return INST_CMP; }
        if (streq_lit(ptr, len, "ret") == 1) { return INST_RET; }
        if (streq_lit(ptr, len, "jmp") == 1) { return INST_JMP; }
        if (streq_lit(ptr, len, "nop") == 1) { return INST_NOP; }
        if (streq_lit(ptr, len, "cld") == 1) { return INST_CLD; }
        if (streq_lit(ptr, len, "rep") == 1) { return INST_REP; }
        if (streq_lit(ptr, len, "pop") == 1) { return INST_POP; }
        if (streq_lit(ptr, len, "jnz") == 1) { return INST_JNZ; }
        if (streq_lit(ptr, len, "jne") == 1) { return INST_JNE; }
        if (streq_lit(ptr, len, "jle") == 1) { return INST_JLE; }
        if (streq_lit(ptr, len, "jge") == 1) { return INST_JGE; }
        if (streq_lit(ptr, len, "jae") == 1) { return INST_JAE; }
        if (streq_lit(ptr, len, "jbe") == 1) { return INST_JBE; }
    }
    if (len == 2) {
        if (streq_lit(ptr, len, "or") == 1) { return INST_OR; }
        if (streq_lit(ptr, len, "jz") == 1) { return INST_JZ; }
        if (streq_lit(ptr, len, "je") == 1) { return INST_JE; }
        if (streq_lit(ptr, len, "jl") == 1) { return INST_JL; }
        if (streq_lit(ptr, len, "jg") == 1) { return INST_JG; }
        if (streq_lit(ptr, len, "ja") == 1) { return INST_JA; }
        if (streq_lit(ptr, len, "jb") == 1) { return INST_JB; }
    }
    if (len == 4) {
        if (streq_lit(ptr, len, "push") == 1) { return INST_PUSH; }
        if (streq_lit(ptr, len, "imul") == 1) { return INST_IMUL; }
        if (streq_lit(ptr, len, "idiv") == 1) { return INST_IDIV; }
        if (streq_lit(ptr, len, "test") == 1) { return INST_TEST; }
        if (streq_lit(ptr, len, "sete") == 1) { return INST_SETE; }
        if (streq_lit(ptr, len, "setl") == 1) { return INST_SETL; }
        if (streq_lit(ptr, len, "setg") == 1) { return INST_SETG; }
        if (streq_lit(ptr, len, "setb") == 1) { return INST_SETB; }
        if (streq_lit(ptr, len, "seta") == 1) { return INST_SETA; }
        if (streq_lit(ptr, len, "call") == 1) { return INST_CALL; }
        if (streq_lit(ptr, len, "movq") == 1) { return INST_MOVQ; }
        if (streq_lit(ptr, len, "movs") == 1) { return INST_MOVSB; }
    }
    if (len == 5) {
        if (streq_lit(ptr, len, "movsb") == 1) { return INST_MOVSB; }
        if (streq_lit(ptr, len, "movsx") == 1) { return INST_MOVSX; }
        if (streq_lit(ptr, len, "movzx") == 1) { return INST_MOVZX; }
        if (streq_lit(ptr, len, "setne") == 1) { return INST_SETNE; }
        if (streq_lit(ptr, len, "setle") == 1) { return INST_SETLE; }
        if (streq_lit(ptr, len, "setge") == 1) { return INST_SETGE; }
        if (streq_lit(ptr, len, "setbe") == 1) { return INST_SETBE; }
        if (streq_lit(ptr, len, "setae") == 1) { return INST_SETAE; }
        if (streq_lit(ptr, len, "addsd") == 1) { return INST_ADDSD; }
        if (streq_lit(ptr, len, "subsd") == 1) { return INST_SUBSD; }
        if (streq_lit(ptr, len, "mulsd") == 1) { return INST_MULSD; }
        if (streq_lit(ptr, len, "divsd") == 1) { return INST_DIVSD; }
        if (streq_lit(ptr, len, "xorpd") == 1) { return INST_XORPD; }
    }
    if (len == 6) {
        if (streq_lit(ptr, len, "movsxd") == 1) { return INST_MOVSXD; }
    }
    if (len == 7) {
        if (streq_lit(ptr, len, "syscall") == 1) { return INST_SYSCALL; }
    }
    if (len == 9) {
        if (streq_lit(ptr, len, "cvttsd2si") == 1) { return INST_CVTTSD2SI; }
    }
    if (len == 8) {
        if (streq_lit(ptr, len, "cvtsi2sd") == 1) { return INST_CVTSI2SD; }
    }
    return INST_NONE;
}

// === Encoding helpers ===
fn make_modrm(m as i32, reg as i32, rm as i32) as i32 {
    return ((m % 4) * 64) + ((reg % 8) * 8) + (rm % 8);
}

fn make_sib(scale as i32, idx as i32, base as i32) as i32 {
    return ((scale % 4) * 64) + ((idx % 8) * 8) + (base % 8);
}

fn make_rex(w as i32, r as i32, x as i32, b as i32) as i32 {
    return 64 + w * 8 + r * 4 + x * 2 + b;
}

fn disp_is8(disp as i64) as i32 {
    if (disp >= (0 - 128) && disp <= 127) { return 1; }
    return 0;
}

fn imm_is8(v as i64) as i32 {
    if (v >= (0 - 128) && v <= 127) { return 1; }
    return 0;
}

fn imm_is32(v as i64) as i32 {
    if (v >= (0 - 2147483648) && v <= 2147483647) { return 1; }
    return 0;
}

// Emit memory operand ModR/M (+ optional SIB + displacement)
// reg_field: the 3-bit /reg field in ModR/M
// base_reg_id: the base register ID (e.g. REG_RBP)
// disp: displacement value
fn emit_mem_modrm(buf as *ByteBuffer, reg_field as i32, base_id as i32, disp as i64) as void {
    let is i32 as base_code = reg_code(base_id);
    let is i32 as need_sib = 0;
    if (base_code == 4) { need_sib = 1; }

    if (disp == 0 && base_code != 5) {
        // mod=00 [base]
        buf_emit8(buf, make_modrm(0, reg_field, base_code));
        if (need_sib == 1) {
            buf_emit8(buf, make_sib(0, 4, base_code));
        }
    } else if (disp_is8(disp) == 1) {
        // mod=01 [base+disp8]
        buf_emit8(buf, make_modrm(1, reg_field, base_code));
        if (need_sib == 1) {
            buf_emit8(buf, make_sib(0, 4, base_code));
        }
        buf_emit8(buf, cast(i32, disp));
    } else {
        // mod=10 [base+disp32]
        buf_emit8(buf, make_modrm(2, reg_field, base_code));
        if (need_sib == 1) {
            buf_emit8(buf, make_sib(0, 4, base_code));
        }
        buf_emit32_le(buf, disp);
    }
}

// Calculate memory operand size (ModR/M + SIB + disp)
fn mem_modrm_size(base_id as i32, disp as i64) as i32 {
    let is i32 as base_code = reg_code(base_id);
    let is i32 as sib = 0;
    if (base_code == 4) { sib = 1; }

    if (disp == 0 && base_code != 5) {
        return 1 + sib;
    } else if (disp_is8(disp) == 1) {
        return 2 + sib;
    } else {
        return 5 + sib;
    }
}

// === Main encoding function ===
// Returns number of bytes emitted. If buf is null-ptr (pass1), still returns size.
fn encode(buf as *ByteBuffer, inst as i32, op1 as *Operand, op2 as *Operand, resolve_label as i64, cur_off as i64) as i32 {
    let is i64 as start = buf.len;

    // --- No-operand instructions ---
    if (inst == INST_RET)     { buf_emit8(buf, 195); return 1; }
    if (inst == INST_SYSCALL) { buf_emit8(buf, 15); buf_emit8(buf, 5); return 2; }
    if (inst == INST_CLD)     { buf_emit8(buf, 252); return 1; }
    if (inst == INST_NOP)     { buf_emit8(buf, 144); return 1; }
    if (inst == INST_CQO)     { buf_emit8(buf, make_rex(1,0,0,0)); buf_emit8(buf, 153); return 2; }
    if (inst == INST_CDQ)     { buf_emit8(buf, 153); return 1; }
    if (inst == INST_MOVSB)   { buf_emit8(buf, 164); return 1; }
    if (inst == INST_REP)     { buf_emit8(buf, 243); return 1; }

    // --- PUSH/POP reg ---
    if (inst == INST_PUSH && op1.kind == OP_REG) {
        let is i32 as code = reg_code(op1.reg_id);
        if (reg_ext(op1.reg_id) == 1) {
            buf_emit8(buf, make_rex(0,0,0,1));
        }
        buf_emit8(buf, 80 + code);
        return cast(i32, buf.len - start);
    }
    if (inst == INST_POP && op1.kind == OP_REG) {
        let is i32 as code = reg_code(op1.reg_id);
        if (reg_ext(op1.reg_id) == 1) {
            buf_emit8(buf, make_rex(0,0,0,1));
        }
        buf_emit8(buf, 88 + code);
        return cast(i32, buf.len - start);
    }

    // --- CALL/JMP/Jcc label ---
    if (inst == INST_CALL && op1.kind == OP_LABEL) {
        buf_emit8(buf, 232);
        let is i64 as rel = resolve_label - (cur_off + 5);
        buf_emit32_le(buf, rel);
        return 5;
    }
    if (inst == INST_JMP && op1.kind == OP_LABEL) {
        buf_emit8(buf, 233);
        let is i64 as rel = resolve_label - (cur_off + 5);
        buf_emit32_le(buf, rel);
        return 5;
    }
    // Jcc: 0F 8x + rel32
    if (inst >= INST_JZ && inst <= INST_JBE && op1.kind == OP_LABEL) {
        buf_emit8(buf, 15);
        let is i32 as cc with mut = 0;
        if (inst == INST_JZ || inst == INST_JE) { cc = 132; }
        if (inst == INST_JNZ || inst == INST_JNE) { cc = 133; }
        if (inst == INST_JL) { cc = 140; }
        if (inst == INST_JLE) { cc = 142; }
        if (inst == INST_JG) { cc = 143; }
        if (inst == INST_JGE) { cc = 141; }
        if (inst == INST_JA) { cc = 135; }
        if (inst == INST_JAE) { cc = 131; }
        if (inst == INST_JB) { cc = 130; }
        if (inst == INST_JBE) { cc = 134; }
        buf_emit8(buf, cc);
        let is i64 as rel = resolve_label - (cur_off + 6);
        buf_emit32_le(buf, rel);
        return 6;
    }

    // --- SETcc reg8 ---
    if (inst >= INST_SETE && inst <= INST_SETAE && op1.kind == OP_REG) {
        let is i32 as cc with mut = 0;
        if (inst == INST_SETE) { cc = 148; }
        if (inst == INST_SETNE) { cc = 149; }
        if (inst == INST_SETL) { cc = 156; }
        if (inst == INST_SETLE) { cc = 158; }
        if (inst == INST_SETG) { cc = 159; }
        if (inst == INST_SETGE) { cc = 157; }
        if (inst == INST_SETB) { cc = 146; }
        if (inst == INST_SETBE) { cc = 150; }
        if (inst == INST_SETA) { cc = 151; }
        if (inst == INST_SETAE) { cc = 147; }
        let is i32 as code = reg_code(op1.reg_id);
        if (reg_ext(op1.reg_id) == 1 || needs_rex_for_8bit(op1.reg_id) == 1) {
            buf_emit8(buf, make_rex(0, 0, 0, reg_ext(op1.reg_id)));
        }
        buf_emit8(buf, 15);
        buf_emit8(buf, cc);
        buf_emit8(buf, make_modrm(3, 0, code));
        return cast(i32, buf.len - start);
    }

    // --- IDIV/NEG/NOT reg ---
    if ((inst == INST_IDIV || inst == INST_NEG || inst == INST_NOT) && op1.kind == OP_REG) {
        let is i32 as sz = reg_size(op1.reg_id);
        let is i32 as code = reg_code(op1.reg_id);
        let is i32 as w = 0;
        if (sz == 64) { w = 1; }
        buf_emit8(buf, make_rex(w, 0, 0, reg_ext(op1.reg_id)));
        buf_emit8(buf, 247);
        let is i32 as ext with mut = 7;
        if (inst == INST_NEG) { ext = 3; }
        if (inst == INST_NOT) { ext = 2; }
        buf_emit8(buf, make_modrm(3, ext, code));
        return cast(i32, buf.len - start);
    }

    // --- MOV ---
    if (inst == INST_MOV) {
        // MOV reg, reg
        if (op1.kind == OP_REG && op2.kind == OP_REG) {
            let is i32 as sz = reg_size(op1.reg_id);
            let is i32 as dst_code = reg_code(op1.reg_id);
            let is i32 as src_code = reg_code(op2.reg_id);
            if (sz == 16) { buf_emit8(buf, 102); }
            let is i32 as need_rex = 0;
            let is i32 as w = 0;
            if (sz == 64) { w = 1; need_rex = 1; }
            if (reg_ext(op2.reg_id) == 1 || reg_ext(op1.reg_id) == 1) { need_rex = 1; }
            if (sz == 8 && (needs_rex_for_8bit(op1.reg_id) == 1 || needs_rex_for_8bit(op2.reg_id) == 1)) { need_rex = 1; }
            if (need_rex == 1) {
                buf_emit8(buf, make_rex(w, reg_ext(op2.reg_id), 0, reg_ext(op1.reg_id)));
            }
            if (sz == 8) { buf_emit8(buf, 136); }
            else { buf_emit8(buf, 137); }
            buf_emit8(buf, make_modrm(3, src_code, dst_code));
            return cast(i32, buf.len - start);
        }

        // MOV reg, imm
        if (op1.kind == OP_REG && op2.kind == OP_IMM) {
            let is i32 as sz = reg_size(op1.reg_id);
            let is i32 as code = reg_code(op1.reg_id);
            if (sz == 64) {
                if (imm_is32(op2.imm) == 1) {
                    buf_emit8(buf, make_rex(1, 0, 0, reg_ext(op1.reg_id)));
                    buf_emit8(buf, 199);
                    buf_emit8(buf, make_modrm(3, 0, code));
                    buf_emit32_le(buf, op2.imm);
                } else {
                    buf_emit8(buf, make_rex(1, 0, 0, reg_ext(op1.reg_id)));
                    buf_emit8(buf, 184 + code);
                    buf_emit64_le(buf, op2.imm);
                }
            } else if (sz == 32) {
                if (reg_ext(op1.reg_id) == 1) {
                    buf_emit8(buf, make_rex(0, 0, 0, 1));
                }
                buf_emit8(buf, 184 + code);
                buf_emit32_le(buf, op2.imm);
            } else if (sz == 16) {
                buf_emit8(buf, 102);
                if (reg_ext(op1.reg_id) == 1) {
                    buf_emit8(buf, make_rex(0, 0, 0, 1));
                }
                buf_emit8(buf, 184 + code);
                buf_emit16_le(buf, cast(i32, op2.imm));
            } else {
                if (reg_ext(op1.reg_id) == 1 || needs_rex_for_8bit(op1.reg_id) == 1) {
                    buf_emit8(buf, make_rex(0, 0, 0, reg_ext(op1.reg_id)));
                }
                buf_emit8(buf, 176 + code);
                buf_emit8(buf, cast(i32, op2.imm));
            }
            return cast(i32, buf.len - start);
        }

        // MOV [mem], reg  (store)
        if (op1.kind == OP_MEM && op2.kind == OP_REG) {
            let is i32 as sz = reg_size(op2.reg_id);
            let is i32 as src_code = reg_code(op2.reg_id);
            if (op1.mem_size > 0 && op1.mem_size < sz) {
                sz = op1.mem_size;
            }
            if (sz == 16) { buf_emit8(buf, 102); }
            let is i32 as need_rex = 0;
            let is i32 as w = 0;
            if (sz == 64) { w = 1; need_rex = 1; }
            if (reg_ext(op2.reg_id) == 1 || reg_ext(op1.mem_base) == 1) { need_rex = 1; }
            if (sz == 8 && needs_rex_for_8bit(op2.reg_id) == 1) { need_rex = 1; }
            if (need_rex == 1) {
                buf_emit8(buf, make_rex(w, reg_ext(op2.reg_id), 0, reg_ext(op1.mem_base)));
            }
            if (sz == 8) { buf_emit8(buf, 136); }
            else { buf_emit8(buf, 137); }
            emit_mem_modrm(buf, src_code, op1.mem_base, op1.mem_disp);
            return cast(i32, buf.len - start);
        }

        // MOV reg, [mem]  (load)
        if (op1.kind == OP_REG && op2.kind == OP_MEM) {
            let is i32 as sz = reg_size(op1.reg_id);
            let is i32 as dst_code = reg_code(op1.reg_id);
            if (sz == 16) { buf_emit8(buf, 102); }
            let is i32 as need_rex = 0;
            let is i32 as w = 0;
            if (sz == 64) { w = 1; need_rex = 1; }
            if (reg_ext(op1.reg_id) == 1 || reg_ext(op2.mem_base) == 1) { need_rex = 1; }
            if (need_rex == 1) {
                buf_emit8(buf, make_rex(w, reg_ext(op1.reg_id), 0, reg_ext(op2.mem_base)));
            }
            if (sz == 8) { buf_emit8(buf, 138); }
            else { buf_emit8(buf, 139); }
            emit_mem_modrm(buf, dst_code, op2.mem_base, op2.mem_disp);
            return cast(i32, buf.len - start);
        }

        // MOV [mem], imm
        if (op1.kind == OP_MEM && op2.kind == OP_IMM) {
            let is i32 as sz = op1.mem_size;
            if (sz == 0) { sz = 64; }
            if (sz == 16) { buf_emit8(buf, 102); }
            let is i32 as need_rex = 0;
            let is i32 as w = 0;
            if (sz == 64) { w = 1; need_rex = 1; }
            if (reg_ext(op1.mem_base) == 1) { need_rex = 1; }
            if (need_rex == 1) {
                buf_emit8(buf, make_rex(w, 0, 0, reg_ext(op1.mem_base)));
            }
            if (sz == 8) { buf_emit8(buf, 198); }
            else { buf_emit8(buf, 199); }
            emit_mem_modrm(buf, 0, op1.mem_base, op1.mem_disp);
            if (sz == 8) { buf_emit8(buf, cast(i32, op2.imm)); }
            else if (sz == 16) { buf_emit16_le(buf, cast(i32, op2.imm)); }
            else { buf_emit32_le(buf, op2.imm); }
            return cast(i32, buf.len - start);
        }
    }

    // --- LEA reg, [mem] ---
    if (inst == INST_LEA) {
        if (op1.kind == OP_REG && op2.kind == OP_MEM) {
            let is i32 as dst_code = reg_code(op1.reg_id);
            buf_emit8(buf, make_rex(1, reg_ext(op1.reg_id), 0, reg_ext(op2.mem_base)));
            buf_emit8(buf, 141);
            emit_mem_modrm(buf, dst_code, op2.mem_base, op2.mem_disp);
            return cast(i32, buf.len - start);
        }
        // LEA reg, [rip+label] — RIP-relative
        if (op1.kind == OP_REG && op2.kind == OP_RIP_LABEL) {
            let is i32 as dst_code = reg_code(op1.reg_id);
            buf_emit8(buf, make_rex(1, reg_ext(op1.reg_id), 0, 0));
            buf_emit8(buf, 141);
            // ModR/M: mod=00, reg=dst, r/m=5 (RIP-relative)
            buf_emit8(buf, make_modrm(0, dst_code, 5));
            // rel32 placeholder — will be a relocation
            let is i64 as rel = resolve_label - (cur_off + cast(i64, buf.len - start) + 4);
            buf_emit32_le(buf, rel);
            return cast(i32, buf.len - start);
        }
    }

    // --- ADD/SUB/AND/OR/XOR/CMP reg, reg ---
    if (inst == INST_ADD || inst == INST_SUB || inst == INST_AND || inst == INST_OR || inst == INST_XOR || inst == INST_CMP) {
        let is i32 as opcode with mut = 0;
        let is i32 as imm_ext with mut = 0;
        if (inst == INST_ADD) { opcode = 1; imm_ext = 0; }
        if (inst == INST_SUB) { opcode = 41; imm_ext = 5; }
        if (inst == INST_AND) { opcode = 33; imm_ext = 4; }
        if (inst == INST_OR)  { opcode = 9; imm_ext = 1; }
        if (inst == INST_XOR) { opcode = 49; imm_ext = 6; }
        if (inst == INST_CMP) { opcode = 57; imm_ext = 7; }

        // reg, reg
        if (op1.kind == OP_REG && op2.kind == OP_REG) {
            let is i32 as sz = reg_size(op1.reg_id);
            let is i32 as dst_code = reg_code(op1.reg_id);
            let is i32 as src_code = reg_code(op2.reg_id);
            if (sz == 16) { buf_emit8(buf, 102); }
            let is i32 as need_rex = 0;
            let is i32 as w = 0;
            if (sz == 64) { w = 1; need_rex = 1; }
            if (reg_ext(op1.reg_id) == 1 || reg_ext(op2.reg_id) == 1) { need_rex = 1; }
            if (need_rex == 1) {
                buf_emit8(buf, make_rex(w, reg_ext(op2.reg_id), 0, reg_ext(op1.reg_id)));
            }
            if (sz == 8) { buf_emit8(buf, opcode - 1); }
            else { buf_emit8(buf, opcode); }
            buf_emit8(buf, make_modrm(3, src_code, dst_code));
            return cast(i32, buf.len - start);
        }

        // reg, imm
        if (op1.kind == OP_REG && op2.kind == OP_IMM) {
            let is i32 as sz = reg_size(op1.reg_id);
            let is i32 as code = reg_code(op1.reg_id);
            let is i32 as w = 0;
            if (sz == 64) { w = 1; }
            if (sz == 16) { buf_emit8(buf, 102); }
            if (w == 1 || reg_ext(op1.reg_id) == 1) {
                buf_emit8(buf, make_rex(w, 0, 0, reg_ext(op1.reg_id)));
            }
            if (imm_is8(op2.imm) == 1 && sz != 8) {
                buf_emit8(buf, 131);
                buf_emit8(buf, make_modrm(3, imm_ext, code));
                buf_emit8(buf, cast(i32, op2.imm));
            } else {
                if (sz == 8) {
                    buf_emit8(buf, 128);
                    buf_emit8(buf, make_modrm(3, imm_ext, code));
                    buf_emit8(buf, cast(i32, op2.imm));
                } else {
                    buf_emit8(buf, 129);
                    buf_emit8(buf, make_modrm(3, imm_ext, code));
                    if (sz == 16) { buf_emit16_le(buf, cast(i32, op2.imm)); }
                    else { buf_emit32_le(buf, op2.imm); }
                }
            }
            return cast(i32, buf.len - start);
        }

        // reg, [mem]
        if (op1.kind == OP_REG && op2.kind == OP_MEM) {
            let is i32 as sz = reg_size(op1.reg_id);
            let is i32 as dst_code = reg_code(op1.reg_id);
            let is i32 as w = 0;
            if (sz == 64) { w = 1; }
            if (sz == 16) { buf_emit8(buf, 102); }
            buf_emit8(buf, make_rex(w, reg_ext(op1.reg_id), 0, reg_ext(op2.mem_base)));
            buf_emit8(buf, opcode + 2);
            emit_mem_modrm(buf, dst_code, op2.mem_base, op2.mem_disp);
            return cast(i32, buf.len - start);
        }
    }

    // --- TEST reg, reg ---
    if (inst == INST_TEST && op1.kind == OP_REG && op2.kind == OP_REG) {
        let is i32 as sz = reg_size(op1.reg_id);
        let is i32 as dst_code = reg_code(op1.reg_id);
        let is i32 as src_code = reg_code(op2.reg_id);
        let is i32 as w = 0;
        if (sz == 64) { w = 1; }
        if (sz == 16) { buf_emit8(buf, 102); }
        let is i32 as need_rex = 0;
        if (w == 1) { need_rex = 1; }
        if (reg_ext(op1.reg_id) == 1 || reg_ext(op2.reg_id) == 1) { need_rex = 1; }
        if (need_rex == 1) {
            buf_emit8(buf, make_rex(w, reg_ext(op2.reg_id), 0, reg_ext(op1.reg_id)));
        }
        if (sz == 8) { buf_emit8(buf, 132); }
        else { buf_emit8(buf, 133); }
        buf_emit8(buf, make_modrm(3, src_code, dst_code));
        return cast(i32, buf.len - start);
    }

    // --- IMUL reg, reg ---
    if (inst == INST_IMUL && op1.kind == OP_REG && op2.kind == OP_REG) {
        let is i32 as sz = reg_size(op1.reg_id);
        let is i32 as w = 0;
        if (sz == 64) { w = 1; }
        buf_emit8(buf, make_rex(w, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
        buf_emit8(buf, 15);
        buf_emit8(buf, 175);
        buf_emit8(buf, make_modrm(3, reg_code(op1.reg_id), reg_code(op2.reg_id)));
        return cast(i32, buf.len - start);
    }

    // --- SHL/SHR/SAR reg, cl ---
    if ((inst == INST_SHL || inst == INST_SHR || inst == INST_SAR) && op1.kind == OP_REG) {
        let is i32 as sz = reg_size(op1.reg_id);
        let is i32 as code = reg_code(op1.reg_id);
        let is i32 as w = 0;
        if (sz == 64) { w = 1; }
        let is i32 as ext with mut = 4;
        if (inst == INST_SHR) { ext = 5; }
        if (inst == INST_SAR) { ext = 7; }

        buf_emit8(buf, make_rex(w, 0, 0, reg_ext(op1.reg_id)));
        if (op2.kind == OP_REG) {
            // shift by CL
            buf_emit8(buf, 211);
            buf_emit8(buf, make_modrm(3, ext, code));
        } else if (op2.kind == OP_IMM) {
            if (op2.imm == 1) {
                buf_emit8(buf, 209);
                buf_emit8(buf, make_modrm(3, ext, code));
            } else {
                buf_emit8(buf, 193);
                buf_emit8(buf, make_modrm(3, ext, code));
                buf_emit8(buf, cast(i32, op2.imm));
            }
        }
        return cast(i32, buf.len - start);
    }

    // --- MOVSXD reg, [mem] or reg ---
    if (inst == INST_MOVSXD) {
        let is i32 as dst_code = reg_code(op1.reg_id);
        buf_emit8(buf, make_rex(1, reg_ext(op1.reg_id), 0, 0));
        if (op2.kind == OP_MEM) {
            let is i64 as rex_pos = buf.len - 1;
            // Fix REX.B
            buf.data[rex_pos] = cast(u8, make_rex(1, reg_ext(op1.reg_id), 0, reg_ext(op2.mem_base)));
            buf_emit8(buf, 99);
            emit_mem_modrm(buf, dst_code, op2.mem_base, op2.mem_disp);
        } else if (op2.kind == OP_REG) {
            buf.data[buf.len - 1] = cast(u8, make_rex(1, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
            buf_emit8(buf, 99);
            buf_emit8(buf, make_modrm(3, dst_code, reg_code(op2.reg_id)));
        }
        return cast(i32, buf.len - start);
    }

    // --- MOVSX reg, [mem] or reg (byte/word) ---
    if (inst == INST_MOVSX) {
        let is i32 as dst_code = reg_code(op1.reg_id);
        if (op2.kind == OP_MEM) {
            let is i32 as w = 1;
            buf_emit8(buf, make_rex(w, reg_ext(op1.reg_id), 0, reg_ext(op2.mem_base)));
            buf_emit8(buf, 15);
            if (op2.mem_size == 8) { buf_emit8(buf, 190); }
            else { buf_emit8(buf, 191); }
            emit_mem_modrm(buf, dst_code, op2.mem_base, op2.mem_disp);
        }
        else if (op2.kind == OP_REG) {
            let is i32 as src_sz = reg_size(op2.reg_id);
            buf_emit8(buf, make_rex(1, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
            buf_emit8(buf, 15);
            if (src_sz == 8) { buf_emit8(buf, 190); }
            else { buf_emit8(buf, 191); }
            buf_emit8(buf, make_modrm(3, dst_code, reg_code(op2.reg_id)));
        }
        return cast(i32, buf.len - start);
    }

    // --- MOVZX reg, [mem] or reg (byte/word) ---
    if (inst == INST_MOVZX) {
        let is i32 as dst_code = reg_code(op1.reg_id);
        if (op2.kind == OP_MEM) {
            let is i32 as w = 0;
            if (reg_size(op1.reg_id) == 64) { w = 1; }
            buf_emit8(buf, make_rex(w, reg_ext(op1.reg_id), 0, reg_ext(op2.mem_base)));
            buf_emit8(buf, 15);
            if (op2.mem_size == 8) { buf_emit8(buf, 182); }
            else { buf_emit8(buf, 183); }
            emit_mem_modrm(buf, dst_code, op2.mem_base, op2.mem_disp);
        }
        else if (op2.kind == OP_REG) {
            let is i32 as src_sz = reg_size(op2.reg_id);
            let is i32 as w = 0;
            if (reg_size(op1.reg_id) == 64) { w = 1; }
            buf_emit8(buf, make_rex(w, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
            buf_emit8(buf, 15);
            if (src_sz == 8) { buf_emit8(buf, 182); }
            else { buf_emit8(buf, 183); }
            buf_emit8(buf, make_modrm(3, dst_code, reg_code(op2.reg_id)));
        }
        return cast(i32, buf.len - start);
    }

    // --- MOVQ (SSE) ---
    if (inst == INST_MOVQ) {
        if (op1.kind == OP_REG && reg_size(op1.reg_id) == 128 && op2.kind == OP_REG) {
            // movq xmm, r64: 66 REX.W 0F 6E
            buf_emit8(buf, 102);
            buf_emit8(buf, make_rex(1, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
            buf_emit8(buf, 15);
            buf_emit8(buf, 110);
            buf_emit8(buf, make_modrm(3, reg_code(op1.reg_id), reg_code(op2.reg_id)));
            return cast(i32, buf.len - start);
        }
        if (op1.kind == OP_REG && op2.kind == OP_REG && reg_size(op2.reg_id) == 128) {
            // movq r64, xmm: 66 REX.W 0F 7E
            buf_emit8(buf, 102);
            buf_emit8(buf, make_rex(1, reg_ext(op2.reg_id), 0, reg_ext(op1.reg_id)));
            buf_emit8(buf, 15);
            buf_emit8(buf, 126);
            buf_emit8(buf, make_modrm(3, reg_code(op2.reg_id), reg_code(op1.reg_id)));
            return cast(i32, buf.len - start);
        }
    }

    // --- SSE arithmetic: addsd/subsd/mulsd/divsd ---
    if (inst == INST_ADDSD || inst == INST_SUBSD || inst == INST_MULSD || inst == INST_DIVSD) {
        if (op1.kind == OP_REG && op2.kind == OP_REG) {
            buf_emit8(buf, 242); // F2 prefix
            let is i32 as need_rex = 0;
            if (reg_ext(op1.reg_id) == 1 || reg_ext(op2.reg_id) == 1) { need_rex = 1; }
            if (need_rex == 1) {
                buf_emit8(buf, make_rex(0, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
            }
            buf_emit8(buf, 15);
            if (inst == INST_ADDSD) { buf_emit8(buf, 88); }
            if (inst == INST_SUBSD) { buf_emit8(buf, 92); }
            if (inst == INST_MULSD) { buf_emit8(buf, 89); }
            if (inst == INST_DIVSD) { buf_emit8(buf, 94); }
            buf_emit8(buf, make_modrm(3, reg_code(op1.reg_id), reg_code(op2.reg_id)));
            return cast(i32, buf.len - start);
        }
    }

    // --- XORPD xmm, xmm ---
    if (inst == INST_XORPD && op1.kind == OP_REG && op2.kind == OP_REG) {
        buf_emit8(buf, 102); // 66 prefix
        let is i32 as need_rex = 0;
        if (reg_ext(op1.reg_id) == 1 || reg_ext(op2.reg_id) == 1) { need_rex = 1; }
        if (need_rex == 1) {
            buf_emit8(buf, make_rex(0, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
        }
        buf_emit8(buf, 15);
        buf_emit8(buf, 87);
        buf_emit8(buf, make_modrm(3, reg_code(op1.reg_id), reg_code(op2.reg_id)));
        return cast(i32, buf.len - start);
    }

    // --- CVTTSD2SI r64, xmm ---
    if (inst == INST_CVTTSD2SI && op1.kind == OP_REG && op2.kind == OP_REG) {
        // F2 REX.W 0F 2C /r (mod=11)
        buf_emit8(buf, 242); // F2
        buf_emit8(buf, make_rex(1, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
        buf_emit8(buf, 15);  // 0F
        buf_emit8(buf, 44);  // 2C
        buf_emit8(buf, make_modrm(3, reg_code(op1.reg_id), reg_code(op2.reg_id)));
        return cast(i32, buf.len - start);
    }

    // --- CVTSI2SD xmm, r64 ---
    if (inst == INST_CVTSI2SD && op1.kind == OP_REG && op2.kind == OP_REG) {
        // F2 REX.W 0F 2A /r (mod=11)
        buf_emit8(buf, 242); // F2
        buf_emit8(buf, make_rex(1, reg_ext(op1.reg_id), 0, reg_ext(op2.reg_id)));
        buf_emit8(buf, 15);  // 0F
        buf_emit8(buf, 42);  // 2A
        buf_emit8(buf, make_modrm(3, reg_code(op1.reg_id), reg_code(op2.reg_id)));
        return cast(i32, buf.len - start);
    }

    // Unknown instruction
    linux.write(linux.STDERR, "ERR: unknown encoding\n", 22);
    return 0;
}
